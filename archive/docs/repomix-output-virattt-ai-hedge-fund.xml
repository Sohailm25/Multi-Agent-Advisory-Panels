<repomix>This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where content has been formatted for parsing, security check has been disabled.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Security check has been disabled - content may contain sensitive information</notes><additional_info></additional_info></file_summary><directory_structure>.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
src/
  agents/
    ben_graham.py
    bill_ackman.py
    cathie_wood.py
    charlie_munger.py
    fundamentals.py
    portfolio_manager.py
    risk_manager.py
    sentiment.py
    stanley_druckenmiller.py
    technicals.py
    valuation.py
    warren_buffett.py
  data/
    cache.py
    models.py
  graph/
    state.py
  llm/
    models.py
  tools/
    api.py
  utils/
    __init__.py
    analysts.py
    display.py
    llm.py
    progress.py
    visualize.py
  backtester.py
  main.py
.env.example
.gitignore
LICENSE
pyproject.toml
README.md</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".github/ISSUE_TEMPLATE/bug_report.md">---
name: Bug report
about: Create a report to help us improve
title: &apos;&apos;
labels: bug
assignees: &apos;&apos;

---

**Describe the bug**
A clear and concise description of what the bug is.

**Screenshot**
Add a screenshot of the bug to help explain your problem.

**Additional context**
Add any other context about the problem here.</file><file path=".github/ISSUE_TEMPLATE/feature_request.md">---
name: Feature request
about: Suggest an idea for this project
title: &apos;&apos;
labels: enhancement
assignees: &apos;&apos;

---

**Describe the feature you&apos;d like**
A clear and concise description of what you want to happen.</file><file path="src/agents/ben_graham.py">from langchain_openai import ChatOpenAI
from graph.state import AgentState, show_agent_reasoning
from tools.api import get_financial_metrics, get_market_cap, search_line_items
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
import json
from typing_extensions import Literal
from utils.progress import progress
from utils.llm import call_llm
import math


class BenGrahamSignal(BaseModel):
    signal: Literal[&quot;bullish&quot;, &quot;bearish&quot;, &quot;neutral&quot;]
    confidence: float
    reasoning: str


def ben_graham_agent(state: AgentState):
    &quot;&quot;&quot;
    Analyzes stocks using Benjamin Graham&apos;s classic value-investing principles:
    1. Earnings stability over multiple years.
    2. Solid financial strength (low debt, adequate liquidity).
    3. Discount to intrinsic value (e.g. Graham Number or net-net).
    4. Adequate margin of safety.
    &quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    analysis_data = {}
    graham_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)
        metrics = get_financial_metrics(ticker, end_date, period=&quot;annual&quot;, limit=10)

        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Gathering financial line items&quot;)
        financial_line_items = search_line_items(ticker, [&quot;earnings_per_share&quot;, &quot;revenue&quot;, &quot;net_income&quot;, &quot;book_value_per_share&quot;, &quot;total_assets&quot;, &quot;total_liabilities&quot;, &quot;current_assets&quot;, &quot;current_liabilities&quot;, &quot;dividends_and_other_cash_distributions&quot;, &quot;outstanding_shares&quot;], end_date, period=&quot;annual&quot;, limit=10)

        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Getting market cap&quot;)
        market_cap = get_market_cap(ticker, end_date)

        # Perform sub-analyses
        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Analyzing earnings stability&quot;)
        earnings_analysis = analyze_earnings_stability(metrics, financial_line_items)

        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Analyzing financial strength&quot;)
        strength_analysis = analyze_financial_strength(metrics, financial_line_items)

        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Analyzing Graham valuation&quot;)
        valuation_analysis = analyze_valuation_graham(metrics, financial_line_items, market_cap)

        # Aggregate scoring
        total_score = earnings_analysis[&quot;score&quot;] + strength_analysis[&quot;score&quot;] + valuation_analysis[&quot;score&quot;]
        max_possible_score = 15  # total possible from the three analysis functions

        # Map total_score to signal
        if total_score &gt;= 0.7 * max_possible_score:
            signal = &quot;bullish&quot;
        elif total_score &lt;= 0.3 * max_possible_score:
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;

        analysis_data[ticker] = {&quot;signal&quot;: signal, &quot;score&quot;: total_score, &quot;max_score&quot;: max_possible_score, &quot;earnings_analysis&quot;: earnings_analysis, &quot;strength_analysis&quot;: strength_analysis, &quot;valuation_analysis&quot;: valuation_analysis}

        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Generating Graham-style analysis&quot;)
        graham_output = generate_graham_output(
            ticker=ticker,
            analysis_data=analysis_data,
            model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
            model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
        )

        graham_analysis[ticker] = {&quot;signal&quot;: graham_output.signal, &quot;confidence&quot;: graham_output.confidence, &quot;reasoning&quot;: graham_output.reasoning}

        progress.update_status(&quot;ben_graham_agent&quot;, ticker, &quot;Done&quot;)

    # Wrap results in a single message for the chain
    message = HumanMessage(content=json.dumps(graham_analysis), name=&quot;ben_graham_agent&quot;)

    # Optionally display reasoning
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(graham_analysis, &quot;Ben Graham Agent&quot;)

    # Store signals in the overall state
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;ben_graham_agent&quot;] = graham_analysis

    return {&quot;messages&quot;: [message], &quot;data&quot;: state[&quot;data&quot;]}


def analyze_earnings_stability(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Graham wants at least several years of consistently positive earnings (ideally 5+).
    We&apos;ll check:
    1. Number of years with positive EPS.
    2. Growth in EPS from first to last period.
    &quot;&quot;&quot;
    score = 0
    details = []

    if not metrics or not financial_line_items:
        return {&quot;score&quot;: score, &quot;details&quot;: &quot;Insufficient data for earnings stability analysis&quot;}

    eps_vals = []
    for item in financial_line_items:
        if item.earnings_per_share is not None:
            eps_vals.append(item.earnings_per_share)

    if len(eps_vals) &lt; 2:
        details.append(&quot;Not enough multi-year EPS data.&quot;)
        return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}

    # 1. Consistently positive EPS
    positive_eps_years = sum(1 for e in eps_vals if e &gt; 0)
    total_eps_years = len(eps_vals)
    if positive_eps_years == total_eps_years:
        score += 3
        details.append(&quot;EPS was positive in all available periods.&quot;)
    elif positive_eps_years &gt;= (total_eps_years * 0.8):
        score += 2
        details.append(&quot;EPS was positive in most periods.&quot;)
    else:
        details.append(&quot;EPS was negative in multiple periods.&quot;)

    # 2. EPS growth from earliest to latest
    if eps_vals[-1] &gt; eps_vals[0]:
        score += 1
        details.append(&quot;EPS grew from earliest to latest period.&quot;)
    else:
        details.append(&quot;EPS did not grow from earliest to latest period.&quot;)

    return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}


def analyze_financial_strength(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Graham checks liquidity (current ratio &gt;= 2), manageable debt,
    and dividend record (preferably some history of dividends).
    &quot;&quot;&quot;
    score = 0
    details = []

    if not financial_line_items:
        return {&quot;score&quot;: score, &quot;details&quot;: &quot;No data for financial strength analysis&quot;}

    latest_item = financial_line_items[-1]
    total_assets = latest_item.total_assets or 0
    total_liabilities = latest_item.total_liabilities or 0
    current_assets = latest_item.current_assets or 0
    current_liabilities = latest_item.current_liabilities or 0

    # 1. Current ratio
    if current_liabilities &gt; 0:
        current_ratio = current_assets / current_liabilities
        if current_ratio &gt;= 2.0:
            score += 2
            details.append(f&quot;Current ratio = {current_ratio:.2f} (&gt;=2.0: solid).&quot;)
        elif current_ratio &gt;= 1.5:
            score += 1
            details.append(f&quot;Current ratio = {current_ratio:.2f} (moderately strong).&quot;)
        else:
            details.append(f&quot;Current ratio = {current_ratio:.2f} (&lt;1.5: weaker liquidity).&quot;)
    else:
        details.append(&quot;Cannot compute current ratio (missing or zero current_liabilities).&quot;)

    # 2. Debt vs. Assets
    if total_assets &gt; 0:
        debt_ratio = total_liabilities / total_assets
        if debt_ratio &lt; 0.5:
            score += 2
            details.append(f&quot;Debt ratio = {debt_ratio:.2f}, under 0.50 (conservative).&quot;)
        elif debt_ratio &lt; 0.8:
            score += 1
            details.append(f&quot;Debt ratio = {debt_ratio:.2f}, somewhat high but could be acceptable.&quot;)
        else:
            details.append(f&quot;Debt ratio = {debt_ratio:.2f}, quite high by Graham standards.&quot;)
    else:
        details.append(&quot;Cannot compute debt ratio (missing total_assets).&quot;)

    # 3. Dividend track record
    div_periods = [item.dividends_and_other_cash_distributions for item in financial_line_items if item.dividends_and_other_cash_distributions is not None]
    if div_periods:
        # In many data feeds, dividend outflow is shown as a negative number
        # (money going out to shareholders). We&apos;ll consider any negative as &apos;paid a dividend&apos;.
        div_paid_years = sum(1 for d in div_periods if d &lt; 0)
        if div_paid_years &gt; 0:
            # e.g. if at least half the periods had dividends
            if div_paid_years &gt;= (len(div_periods) // 2 + 1):
                score += 1
                details.append(&quot;Company paid dividends in the majority of the reported years.&quot;)
            else:
                details.append(&quot;Company has some dividend payments, but not most years.&quot;)
        else:
            details.append(&quot;Company did not pay dividends in these periods.&quot;)
    else:
        details.append(&quot;No dividend data available to assess payout consistency.&quot;)

    return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}


def analyze_valuation_graham(metrics: list, financial_line_items: list, market_cap: float) -&gt; dict:
    &quot;&quot;&quot;
    Core Graham approach to valuation:
    1. Net-Net Check: (Current Assets - Total Liabilities) vs. Market Cap
    2. Graham Number: sqrt(22.5 * EPS * Book Value per Share)
    3. Compare per-share price to Graham Number =&gt; margin of safety
    &quot;&quot;&quot;
    if not financial_line_items or not market_cap or market_cap &lt;= 0:
        return {&quot;score&quot;: 0, &quot;details&quot;: &quot;Insufficient data to perform valuation&quot;}

    latest = financial_line_items[-1]
    current_assets = latest.current_assets or 0
    total_liabilities = latest.total_liabilities or 0
    book_value_ps = latest.book_value_per_share or 0
    eps = latest.earnings_per_share or 0
    shares_outstanding = latest.outstanding_shares or 0

    details = []
    score = 0

    # 1. Net-Net Check
    #   NCAV = Current Assets - Total Liabilities
    #   If NCAV &gt; Market Cap =&gt; historically a strong buy signal
    net_current_asset_value = current_assets - total_liabilities
    if net_current_asset_value &gt; 0 and shares_outstanding &gt; 0:
        net_current_asset_value_per_share = net_current_asset_value / shares_outstanding
        price_per_share = market_cap / shares_outstanding if shares_outstanding else 0

        details.append(f&quot;Net Current Asset Value = {net_current_asset_value:,.2f}&quot;)
        details.append(f&quot;NCAV Per Share = {net_current_asset_value_per_share:,.2f}&quot;)
        details.append(f&quot;Price Per Share = {price_per_share:,.2f}&quot;)

        if net_current_asset_value &gt; market_cap:
            score += 4  # Very strong Graham signal
            details.append(&quot;Net-Net: NCAV &gt; Market Cap (classic Graham deep value).&quot;)
        else:
            # For partial net-net discount
            if net_current_asset_value_per_share &gt;= (price_per_share * 0.67):
                score += 2
                details.append(&quot;NCAV Per Share &gt;= 2/3 of Price Per Share (moderate net-net discount).&quot;)
    else:
        details.append(&quot;NCAV not exceeding market cap or insufficient data for net-net approach.&quot;)

    # 2. Graham Number
    #   GrahamNumber = sqrt(22.5 * EPS * BVPS).
    #   Compare the result to the current price_per_share
    #   If GrahamNumber &gt;&gt; price, indicates undervaluation
    graham_number = None
    if eps &gt; 0 and book_value_ps &gt; 0:
        graham_number = math.sqrt(22.5 * eps * book_value_ps)
        details.append(f&quot;Graham Number = {graham_number:.2f}&quot;)
    else:
        details.append(&quot;Unable to compute Graham Number (EPS or Book Value missing/&lt;=0).&quot;)

    # 3. Margin of Safety relative to Graham Number
    if graham_number and shares_outstanding &gt; 0:
        current_price = market_cap / shares_outstanding
        if current_price &gt; 0:
            margin_of_safety = (graham_number - current_price) / current_price
            details.append(f&quot;Margin of Safety (Graham Number) = {margin_of_safety:.2%}&quot;)
            if margin_of_safety &gt; 0.5:
                score += 3
                details.append(&quot;Price is well below Graham Number (&gt;=50% margin).&quot;)
            elif margin_of_safety &gt; 0.2:
                score += 1
                details.append(&quot;Some margin of safety relative to Graham Number.&quot;)
            else:
                details.append(&quot;Price close to or above Graham Number, low margin of safety.&quot;)
        else:
            details.append(&quot;Current price is zero or invalid; can&apos;t compute margin of safety.&quot;)
    # else: already appended details for missing graham_number

    return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}


def generate_graham_output(
    ticker: str,
    analysis_data: dict[str, any],
    model_name: str,
    model_provider: str,
) -&gt; BenGrahamSignal:
    &quot;&quot;&quot;
    Generates an investment decision in the style of Benjamin Graham:
    - Value emphasis, margin of safety, net-nets, conservative balance sheet, stable earnings.
    - Return the result in a JSON structure: { signal, confidence, reasoning }.
    &quot;&quot;&quot;

    template = ChatPromptTemplate.from_messages([
        (
            &quot;system&quot;,
            &quot;&quot;&quot;You are a Benjamin Graham AI agent, making investment decisions using his principles:
            1. Insist on a margin of safety by buying below intrinsic value (e.g., using Graham Number, net-net).
            2. Emphasize the company&apos;s financial strength (low leverage, ample current assets).
            3. Prefer stable earnings over multiple years.
            4. Consider dividend record for extra safety.
            5. Avoid speculative or high-growth assumptions; focus on proven metrics.
                        
            Return a rational recommendation: bullish, bearish, or neutral, with a confidence level (0-100) and concise reasoning.
            &quot;&quot;&quot;
        ),
        (
            &quot;human&quot;,
            &quot;&quot;&quot;Based on the following analysis, create a Graham-style investment signal:

            Analysis Data for {ticker}:
            {analysis_data}

            Return JSON exactly in this format:
            {{
              &quot;signal&quot;: &quot;bullish&quot; or &quot;bearish&quot; or &quot;neutral&quot;,
              &quot;confidence&quot;: float (0-100),
              &quot;reasoning&quot;: &quot;string&quot;
            }}
            &quot;&quot;&quot;
        )
    ])

    prompt = template.invoke({
        &quot;analysis_data&quot;: json.dumps(analysis_data, indent=2),
        &quot;ticker&quot;: ticker
    })

    def create_default_ben_graham_signal():
        return BenGrahamSignal(signal=&quot;neutral&quot;, confidence=0.0, reasoning=&quot;Error in generating analysis; defaulting to neutral.&quot;)

    return call_llm(
        prompt=prompt,
        model_name=model_name,
        model_provider=model_provider,
        pydantic_model=BenGrahamSignal,
        agent_name=&quot;ben_graham_agent&quot;,
        default_factory=create_default_ben_graham_signal,
    )</file><file path="src/agents/bill_ackman.py">from langchain_openai import ChatOpenAI
from graph.state import AgentState, show_agent_reasoning
from tools.api import get_financial_metrics, get_market_cap, search_line_items
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
import json
from typing_extensions import Literal
from utils.progress import progress
from utils.llm import call_llm

class BillAckmanSignal(BaseModel):
    signal: Literal[&quot;bullish&quot;, &quot;bearish&quot;, &quot;neutral&quot;]
    confidence: float
    reasoning: str


def bill_ackman_agent(state: AgentState):
    &quot;&quot;&quot;
    Analyzes stocks using Bill Ackman&apos;s investing principles and LLM reasoning.
    Fetches multiple periods of data so we can analyze long-term trends.
    &quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]
    
    analysis_data = {}
    ackman_analysis = {}
    
    for ticker in tickers:
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)
        # You can adjust these parameters (period=&quot;annual&quot;/&quot;ttm&quot;, limit=5/10, etc.)
        metrics = get_financial_metrics(ticker, end_date, period=&quot;annual&quot;, limit=5)
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Gathering financial line items&quot;)
        # Request multiple periods of data (annual or TTM) for a more robust long-term view.
        financial_line_items = search_line_items(
            ticker,
            [
                &quot;revenue&quot;,
                &quot;operating_margin&quot;,
                &quot;debt_to_equity&quot;,
                &quot;free_cash_flow&quot;,
                &quot;total_assets&quot;,
                &quot;total_liabilities&quot;,
                &quot;dividends_and_other_cash_distributions&quot;,
                &quot;outstanding_shares&quot;
            ],
            end_date,
            period=&quot;annual&quot;,  # or &quot;ttm&quot; if you prefer trailing 12 months
            limit=5           # fetch up to 5 annual periods (or more if needed)
        )
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Getting market cap&quot;)
        market_cap = get_market_cap(ticker, end_date)
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Analyzing business quality&quot;)
        quality_analysis = analyze_business_quality(metrics, financial_line_items)
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Analyzing balance sheet and capital structure&quot;)
        balance_sheet_analysis = analyze_financial_discipline(metrics, financial_line_items)
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Calculating intrinsic value &amp; margin of safety&quot;)
        valuation_analysis = analyze_valuation(financial_line_items, market_cap)
        
        # Combine partial scores or signals
        total_score = quality_analysis[&quot;score&quot;] + balance_sheet_analysis[&quot;score&quot;] + valuation_analysis[&quot;score&quot;]
        max_possible_score = 15  # Adjust weighting as desired
        
        # Generate a simple buy/hold/sell (bullish/neutral/bearish) signal
        if total_score &gt;= 0.7 * max_possible_score:
            signal = &quot;bullish&quot;
        elif total_score &lt;= 0.3 * max_possible_score:
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;
        
        analysis_data[ticker] = {
            &quot;signal&quot;: signal,
            &quot;score&quot;: total_score,
            &quot;max_score&quot;: max_possible_score,
            &quot;quality_analysis&quot;: quality_analysis,
            &quot;balance_sheet_analysis&quot;: balance_sheet_analysis,
            &quot;valuation_analysis&quot;: valuation_analysis
        }
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Generating Ackman analysis&quot;)
        ackman_output = generate_ackman_output(
            ticker=ticker, 
            analysis_data=analysis_data,
            model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
            model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
        )
        
        ackman_analysis[ticker] = {
            &quot;signal&quot;: ackman_output.signal,
            &quot;confidence&quot;: ackman_output.confidence,
            &quot;reasoning&quot;: ackman_output.reasoning
        }
        
        progress.update_status(&quot;bill_ackman_agent&quot;, ticker, &quot;Done&quot;)
    
    # Wrap results in a single message for the chain
    message = HumanMessage(
        content=json.dumps(ackman_analysis),
        name=&quot;bill_ackman_agent&quot;
    )
    
    # Show reasoning if requested
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(ackman_analysis, &quot;Bill Ackman Agent&quot;)
    
    # Add signals to the overall state
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;bill_ackman_agent&quot;] = ackman_analysis

    return {
        &quot;messages&quot;: [message],
        &quot;data&quot;: state[&quot;data&quot;]
    }


def analyze_business_quality(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Analyze whether the company has a high-quality business with stable or growing cash flows,
    durable competitive advantages, and potential for long-term growth.
    &quot;&quot;&quot;
    score = 0
    details = []
    
    if not metrics or not financial_line_items:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze business quality&quot;
        }
    
    # 1. Multi-period revenue growth analysis
    revenues = [item.revenue for item in financial_line_items if item.revenue is not None]
    if len(revenues) &gt;= 2:
        # Check if overall revenue grew from first to last
        initial, final = revenues[0], revenues[-1]
        if initial and final and final &gt; initial:
            # Simple growth rate
            growth_rate = (final - initial) / abs(initial)
            if growth_rate &gt; 0.5:  # e.g., 50% growth over the available time
                score += 2
                details.append(f&quot;Revenue grew by {(growth_rate*100):.1f}% over the full period.&quot;)
            else:
                score += 1
                details.append(f&quot;Revenue growth is positive but under 50% cumulatively ({(growth_rate*100):.1f}%).&quot;)
        else:
            details.append(&quot;Revenue did not grow significantly or data insufficient.&quot;)
    else:
        details.append(&quot;Not enough revenue data for multi-period trend.&quot;)
    
    # 2. Operating margin and free cash flow consistency
    # We&apos;ll check if operating_margin or free_cash_flow are consistently positive/improving
    fcf_vals = [item.free_cash_flow for item in financial_line_items if item.free_cash_flow is not None]
    op_margin_vals = [item.operating_margin for item in financial_line_items if item.operating_margin is not None]
    
    if op_margin_vals:
        # Check if the majority of operating margins are &gt; 15%
        above_15 = sum(1 for m in op_margin_vals if m &gt; 0.15)
        if above_15 &gt;= (len(op_margin_vals) // 2 + 1):
            score += 2
            details.append(&quot;Operating margins have often exceeded 15%.&quot;)
        else:
            details.append(&quot;Operating margin not consistently above 15%.&quot;)
    else:
        details.append(&quot;No operating margin data across periods.&quot;)
    
    if fcf_vals:
        # Check if free cash flow is positive in most periods
        positive_fcf_count = sum(1 for f in fcf_vals if f &gt; 0)
        if positive_fcf_count &gt;= (len(fcf_vals) // 2 + 1):
            score += 1
            details.append(&quot;Majority of periods show positive free cash flow.&quot;)
        else:
            details.append(&quot;Free cash flow not consistently positive.&quot;)
    else:
        details.append(&quot;No free cash flow data across periods.&quot;)
    
    # 3. Return on Equity (ROE) check from the latest metrics
    # (If you want multi-period ROE, you&apos;d need that in financial_line_items as well.)
    latest_metrics = metrics[0]
    if latest_metrics.return_on_equity and latest_metrics.return_on_equity &gt; 0.15:
        score += 2
        details.append(f&quot;High ROE of {latest_metrics.return_on_equity:.1%}, indicating potential moat.&quot;)
    elif latest_metrics.return_on_equity:
        details.append(f&quot;ROE of {latest_metrics.return_on_equity:.1%} is not indicative of a strong moat.&quot;)
    else:
        details.append(&quot;ROE data not available in metrics.&quot;)
    
    return {
        &quot;score&quot;: score,
        &quot;details&quot;: &quot;; &quot;.join(details)
    }


def analyze_financial_discipline(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Evaluate the company&apos;s balance sheet over multiple periods:
    - Debt ratio trends
    - Capital returns to shareholders over time (dividends, buybacks)
    &quot;&quot;&quot;
    score = 0
    details = []
    
    if not metrics or not financial_line_items:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze financial discipline&quot;
        }
    
    # 1. Multi-period debt ratio or debt_to_equity
    # Check if the companyâ€™s leverage is stable or improving
    debt_to_equity_vals = [item.debt_to_equity for item in financial_line_items if item.debt_to_equity is not None]
    
    # If we have multi-year data, see if D/E ratio has gone down or stayed &lt;1 across most periods
    if debt_to_equity_vals:
        below_one_count = sum(1 for d in debt_to_equity_vals if d &lt; 1.0)
        if below_one_count &gt;= (len(debt_to_equity_vals) // 2 + 1):
            score += 2
            details.append(&quot;Debt-to-equity &lt; 1.0 for the majority of periods.&quot;)
        else:
            details.append(&quot;Debt-to-equity &gt;= 1.0 in many periods.&quot;)
    else:
        # Fallback to total_liabilities/total_assets if D/E not available
        liab_to_assets = []
        for item in financial_line_items:
            if item.total_liabilities and item.total_assets and item.total_assets &gt; 0:
                liab_to_assets.append(item.total_liabilities / item.total_assets)
        
        if liab_to_assets:
            below_50pct_count = sum(1 for ratio in liab_to_assets if ratio &lt; 0.5)
            if below_50pct_count &gt;= (len(liab_to_assets) // 2 + 1):
                score += 2
                details.append(&quot;Liabilities-to-assets &lt; 50% for majority of periods.&quot;)
            else:
                details.append(&quot;Liabilities-to-assets &gt;= 50% in many periods.&quot;)
        else:
            details.append(&quot;No consistent leverage ratio data available.&quot;)
    
    # 2. Capital allocation approach (dividends + share counts)
    # If the company paid dividends or reduced share count over time, it may reflect discipline
    dividends_list = [item.dividends_and_other_cash_distributions for item in financial_line_items if item.dividends_and_other_cash_distributions is not None]
    if dividends_list:
        # Check if dividends were paid (i.e., negative outflows to shareholders) in most periods
        paying_dividends_count = sum(1 for d in dividends_list if d &lt; 0)
        if paying_dividends_count &gt;= (len(dividends_list) // 2 + 1):
            score += 1
            details.append(&quot;Company has a history of returning capital to shareholders (dividends).&quot;)
        else:
            details.append(&quot;Dividends not consistently paid or no data.&quot;)
    else:
        details.append(&quot;No dividend data found across periods.&quot;)
    
    # Check for decreasing share count (simple approach):
    # We can compare first vs last if we have at least two data points
    shares = [item.outstanding_shares for item in financial_line_items if item.outstanding_shares is not None]
    if len(shares) &gt;= 2:
        if shares[-1] &lt; shares[0]:
            score += 1
            details.append(&quot;Outstanding shares have decreased over time (possible buybacks).&quot;)
        else:
            details.append(&quot;Outstanding shares have not decreased over the available periods.&quot;)
    else:
        details.append(&quot;No multi-period share count data to assess buybacks.&quot;)
    
    return {
        &quot;score&quot;: score,
        &quot;details&quot;: &quot;; &quot;.join(details)
    }


def analyze_valuation(financial_line_items: list, market_cap: float) -&gt; dict:
    &quot;&quot;&quot;
    Ackman invests in companies trading at a discount to intrinsic value.
    We can do a simplified DCF or an FCF-based approach.
    This function currently uses the latest free cash flow only, 
    but you could expand it to use an average or multi-year FCF approach.
    &quot;&quot;&quot;
    if not financial_line_items or market_cap is None:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to perform valuation&quot;
        }
    
    # Example: use the most recent item for FCF
    latest = financial_line_items[-1]  # the last one is presumably the most recent
    fcf = latest.free_cash_flow if latest.free_cash_flow else 0
    
    # For demonstration, let&apos;s do a naive approach:
    growth_rate = 0.06
    discount_rate = 0.10
    terminal_multiple = 15
    projection_years = 5
    
    if fcf &lt;= 0:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: f&quot;No positive FCF for valuation; FCF = {fcf}&quot;,
            &quot;intrinsic_value&quot;: None
        }
    
    present_value = 0
    for year in range(1, projection_years + 1):
        future_fcf = fcf * (1 + growth_rate) ** year
        pv = future_fcf / ((1 + discount_rate) ** year)
        present_value += pv
    
    # Terminal Value
    terminal_value = (fcf * (1 + growth_rate) ** projection_years * terminal_multiple) \
                     / ((1 + discount_rate) ** projection_years)
    intrinsic_value = present_value + terminal_value
    
    # Compare with market cap =&gt; margin of safety
    margin_of_safety = (intrinsic_value - market_cap) / market_cap
    
    score = 0
    if margin_of_safety &gt; 0.3:
        score += 3
    elif margin_of_safety &gt; 0.1:
        score += 1
    
    details = [
        f&quot;Calculated intrinsic value: ~{intrinsic_value:,.2f}&quot;,
        f&quot;Market cap: ~{market_cap:,.2f}&quot;,
        f&quot;Margin of safety: {margin_of_safety:.2%}&quot;
    ]
    
    return {
        &quot;score&quot;: score,
        &quot;details&quot;: &quot;; &quot;.join(details),
        &quot;intrinsic_value&quot;: intrinsic_value,
        &quot;margin_of_safety&quot;: margin_of_safety
    }


def generate_ackman_output(
    ticker: str,
    analysis_data: dict[str, any],
    model_name: str,
    model_provider: str,
) -&gt; BillAckmanSignal:
    &quot;&quot;&quot;
    Generates investment decisions in the style of Bill Ackman.
    &quot;&quot;&quot;
    template = ChatPromptTemplate.from_messages([
        (
            &quot;system&quot;,
            &quot;&quot;&quot;You are a Bill Ackman AI agent, making investment decisions using his principles:

            1. Seek high-quality businesses with durable competitive advantages (moats).
            2. Prioritize consistent free cash flow and growth potential.
            3. Advocate for strong financial discipline (reasonable leverage, efficient capital allocation).
            4. Valuation matters: target intrinsic value and margin of safety.
            5. Invest with high conviction in a concentrated portfolio for the long term.
            6. Potential activist approach if management or operational improvements can unlock value.
            
            Rules:
            - Evaluate brand strength, market position, or other moats.
            - Check free cash flow generation, stable or growing earnings.
            - Analyze balance sheet health (reasonable debt, good ROE).
            - Buy at a discount to intrinsic value; higher discount =&gt; stronger conviction.
            - Engage if management is suboptimal or if there&apos;s a path for strategic improvements.
            - Provide a rational, data-driven recommendation (bullish, bearish, or neutral).&quot;&quot;&quot;
        ),
        (
            &quot;human&quot;,
            &quot;&quot;&quot;Based on the following analysis, create an Ackman-style investment signal.

            Analysis Data for {ticker}:
            {analysis_data}

            Return the trading signal in this JSON format:
            {{
              &quot;signal&quot;: &quot;bullish/bearish/neutral&quot;,
              &quot;confidence&quot;: float (0-100),
              &quot;reasoning&quot;: &quot;string&quot;
            }}
            &quot;&quot;&quot;
        )
    ])

    prompt = template.invoke({
        &quot;analysis_data&quot;: json.dumps(analysis_data, indent=2),
        &quot;ticker&quot;: ticker
    })

    def create_default_bill_ackman_signal():
        return BillAckmanSignal(
            signal=&quot;neutral&quot;,
            confidence=0.0,
            reasoning=&quot;Error in analysis, defaulting to neutral&quot;
        )

    return call_llm(
        prompt=prompt, 
        model_name=model_name, 
        model_provider=model_provider, 
        pydantic_model=BillAckmanSignal, 
        agent_name=&quot;bill_ackman_agent&quot;, 
        default_factory=create_default_bill_ackman_signal,
    )</file><file path="src/agents/cathie_wood.py">from langchain_openai import ChatOpenAI
from graph.state import AgentState, show_agent_reasoning
from tools.api import get_financial_metrics, get_market_cap, search_line_items
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
import json
from typing_extensions import Literal
from utils.progress import progress
from utils.llm import call_llm

class CathieWoodSignal(BaseModel):
    signal: Literal[&quot;bullish&quot;, &quot;bearish&quot;, &quot;neutral&quot;]
    confidence: float
    reasoning: str


def cathie_wood_agent(state: AgentState):
    &quot;&quot;&quot;
    Analyzes stocks using Cathie Wood&apos;s investing principles and LLM reasoning.
    1. Prioritizes companies with breakthrough technologies or business models
    2. Focuses on industries with rapid adoption curves and massive TAM (Total Addressable Market).
    3. Invests mostly in AI, robotics, genomic sequencing, fintech, and blockchain.
    4. Willing to endure short-term volatility for long-term gains.
    &quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    analysis_data = {}
    cw_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)
        # You can adjust these parameters (period=&quot;annual&quot;/&quot;ttm&quot;, limit=5/10, etc.)
        metrics = get_financial_metrics(ticker, end_date, period=&quot;annual&quot;, limit=5)

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Gathering financial line items&quot;)
        # Request multiple periods of data (annual or TTM) for a more robust view.
        financial_line_items = search_line_items(
            ticker,
            [
                &quot;revenue&quot;,
                &quot;gross_margin&quot;,
                &quot;operating_margin&quot;,
                &quot;debt_to_equity&quot;,
                &quot;free_cash_flow&quot;,
                &quot;total_assets&quot;,
                &quot;total_liabilities&quot;,
                &quot;dividends_and_other_cash_distributions&quot;,
                &quot;outstanding_shares&quot;,
                &quot;research_and_development&quot;,
                &quot;capital_expenditure&quot;,
                &quot;operating_expense&quot;,

            ],
            end_date,
            period=&quot;annual&quot;,
            limit=5
        )

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Getting market cap&quot;)
        market_cap = get_market_cap(ticker, end_date)

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Analyzing disruptive potential&quot;)
        disruptive_analysis = analyze_disruptive_potential(metrics, financial_line_items)

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Analyzing innovation-driven growth&quot;)
        innovation_analysis = analyze_innovation_growth(metrics, financial_line_items)

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Calculating valuation &amp; high-growth scenario&quot;)
        valuation_analysis = analyze_cathie_wood_valuation(financial_line_items, market_cap)

        # Combine partial scores or signals
        total_score = disruptive_analysis[&quot;score&quot;] + innovation_analysis[&quot;score&quot;] + valuation_analysis[&quot;score&quot;]
        max_possible_score = 15  # Adjust weighting as desired

        if total_score &gt;= 0.7 * max_possible_score:
            signal = &quot;bullish&quot;
        elif total_score &lt;= 0.3 * max_possible_score:
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;

        analysis_data[ticker] = {
            &quot;signal&quot;: signal,
            &quot;score&quot;: total_score,
            &quot;max_score&quot;: max_possible_score,
            &quot;disruptive_analysis&quot;: disruptive_analysis,
            &quot;innovation_analysis&quot;: innovation_analysis,
            &quot;valuation_analysis&quot;: valuation_analysis
        }

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Generating Cathie Wood style analysis&quot;)
        cw_output = generate_cathie_wood_output(
            ticker=ticker,
            analysis_data=analysis_data,
            model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
            model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
        )

        cw_analysis[ticker] = {
            &quot;signal&quot;: cw_output.signal,
            &quot;confidence&quot;: cw_output.confidence,
            &quot;reasoning&quot;: cw_output.reasoning
        }

        progress.update_status(&quot;cathie_wood_agent&quot;, ticker, &quot;Done&quot;)

    message = HumanMessage(
        content=json.dumps(cw_analysis),
        name=&quot;cathie_wood_agent&quot;
    )

    if state[&quot;metadata&quot;].get(&quot;show_reasoning&quot;):
        show_agent_reasoning(cw_analysis, &quot;Cathie Wood Agent&quot;)

    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;cathie_wood_agent&quot;] = cw_analysis

    return {
        &quot;messages&quot;: [message],
        &quot;data&quot;: state[&quot;data&quot;]
    }


def analyze_disruptive_potential(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Analyze whether the company has disruptive products, technology, or business model.
    Evaluates multiple dimensions of disruptive potential:
    1. Revenue Growth Acceleration - indicates market adoption
    2. R&amp;D Intensity - shows innovation investment
    3. Gross Margin Trends - suggests pricing power and scalability
    4. Operating Leverage - demonstrates business model efficiency
    5. Market Share Dynamics - indicates competitive position
    &quot;&quot;&quot;
    score = 0
    details = []

    if not metrics or not financial_line_items:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze disruptive potential&quot;
        }

    # 1. Revenue Growth Analysis - Check for accelerating growth
    revenues = [item.revenue for item in financial_line_items if item.revenue]
    if len(revenues) &gt;= 3:  # Need at least 3 periods to check acceleration
        growth_rates = []
        for i in range(len(revenues)-1):
            if revenues[i] and revenues[i+1]:
                growth_rate = (revenues[i+1] - revenues[i]) / abs(revenues[i]) if revenues[i] != 0 else 0
                growth_rates.append(growth_rate)

        # Check if growth is accelerating
        if len(growth_rates) &gt;= 2 and growth_rates[-1] &gt; growth_rates[0]:
            score += 2
            details.append(f&quot;Revenue growth is accelerating: {(growth_rates[-1]*100):.1f}% vs {(growth_rates[0]*100):.1f}%&quot;)

        # Check absolute growth rate
        latest_growth = growth_rates[-1] if growth_rates else 0
        if latest_growth &gt; 1.0:
            score += 3
            details.append(f&quot;Exceptional revenue growth: {(latest_growth*100):.1f}%&quot;)
        elif latest_growth &gt; 0.5:
            score += 2
            details.append(f&quot;Strong revenue growth: {(latest_growth*100):.1f}%&quot;)
        elif latest_growth &gt; 0.2:
            score += 1
            details.append(f&quot;Moderate revenue growth: {(latest_growth*100):.1f}%&quot;)
    else:
        details.append(&quot;Insufficient revenue data for growth analysis&quot;)

    # 2. Gross Margin Analysis - Check for expanding margins
    gross_margins = [item.gross_margin for item in financial_line_items if hasattr(item, &apos;gross_margin&apos;) and item.gross_margin is not None]
    if len(gross_margins) &gt;= 2:
        margin_trend = gross_margins[-1] - gross_margins[0]
        if margin_trend &gt; 0.05:  # 5% improvement
            score += 2
            details.append(f&quot;Expanding gross margins: +{(margin_trend*100):.1f}%&quot;)
        elif margin_trend &gt; 0:
            score += 1
            details.append(f&quot;Slightly improving gross margins: +{(margin_trend*100):.1f}%&quot;)

        # Check absolute margin level
        if gross_margins[-1] &gt; 0.50:  # High margin business
            score += 2
            details.append(f&quot;High gross margin: {(gross_margins[-1]*100):.1f}%&quot;)
    else:
        details.append(&quot;Insufficient gross margin data&quot;)

    # 3. Operating Leverage Analysis
    revenues = [item.revenue for item in financial_line_items if item.revenue]
    operating_expenses = [
        item.operating_expense
        for item in financial_line_items
        if hasattr(item, &quot;operating_expense&quot;) and item.operating_expense
    ]

    if len(revenues) &gt;= 2 and len(operating_expenses) &gt;= 2:
        rev_growth = (revenues[-1] - revenues[0]) / abs(revenues[0])
        opex_growth = (operating_expenses[-1] - operating_expenses[0]) / abs(operating_expenses[0])

        if rev_growth &gt; opex_growth:
            score += 2
            details.append(&quot;Positive operating leverage: Revenue growing faster than expenses&quot;)
    else:
        details.append(&quot;Insufficient data for operating leverage analysis&quot;)

    # 4. R&amp;D Investment Analysis
    rd_expenses = [item.research_and_development for item in financial_line_items if hasattr(item, &apos;research_and_development&apos;) and item.research_and_development is not None]
    if rd_expenses and revenues:
        rd_intensity = rd_expenses[-1] / revenues[-1]
        if rd_intensity &gt; 0.15:  # High R&amp;D intensity
            score += 3
            details.append(f&quot;High R&amp;D investment: {(rd_intensity*100):.1f}% of revenue&quot;)
        elif rd_intensity &gt; 0.08:
            score += 2
            details.append(f&quot;Moderate R&amp;D investment: {(rd_intensity*100):.1f}% of revenue&quot;)
        elif rd_intensity &gt; 0.05:
            score += 1
            details.append(f&quot;Some R&amp;D investment: {(rd_intensity*100):.1f}% of revenue&quot;)
    else:
        details.append(&quot;No R&amp;D data available&quot;)

    # Normalize score to be out of 5
    max_possible_score = 12  # Sum of all possible points
    normalized_score = (score / max_possible_score) * 5

    return {
        &quot;score&quot;: normalized_score,
        &quot;details&quot;: &quot;; &quot;.join(details),
        &quot;raw_score&quot;: score,
        &quot;max_score&quot;: max_possible_score
    }


def analyze_innovation_growth(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Evaluate the company&apos;s commitment to innovation and potential for exponential growth.
    Analyzes multiple dimensions:
    1. R&amp;D Investment Trends - measures commitment to innovation
    2. Free Cash Flow Generation - indicates ability to fund innovation
    3. Operating Efficiency - shows scalability of innovation
    4. Capital Allocation - reveals innovation-focused management
    5. Growth Reinvestment - demonstrates commitment to future growth
    &quot;&quot;&quot;
    score = 0
    details = []

    if not metrics or not financial_line_items:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze innovation-driven growth&quot;
        }

    # 1. R&amp;D Investment Trends
    rd_expenses = [
        item.research_and_development
        for item in financial_line_items
        if hasattr(item, &quot;research_and_development&quot;) and item.research_and_development
    ]
    revenues = [item.revenue for item in financial_line_items if item.revenue]

    if rd_expenses and revenues and len(rd_expenses) &gt;= 2:
        # Check R&amp;D growth rate
        rd_growth = (rd_expenses[-1] - rd_expenses[0]) / abs(rd_expenses[0]) if rd_expenses[0] != 0 else 0
        if rd_growth &gt; 0.5:  # 50% growth in R&amp;D
            score += 3
            details.append(f&quot;Strong R&amp;D investment growth: +{(rd_growth*100):.1f}%&quot;)
        elif rd_growth &gt; 0.2:
            score += 2
            details.append(f&quot;Moderate R&amp;D investment growth: +{(rd_growth*100):.1f}%&quot;)

        # Check R&amp;D intensity trend
        rd_intensity_start = rd_expenses[0] / revenues[0]
        rd_intensity_end = rd_expenses[-1] / revenues[-1]
        if rd_intensity_end &gt; rd_intensity_start:
            score += 2
            details.append(f&quot;Increasing R&amp;D intensity: {(rd_intensity_end*100):.1f}% vs {(rd_intensity_start*100):.1f}%&quot;)
    else:
        details.append(&quot;Insufficient R&amp;D data for trend analysis&quot;)

    # 2. Free Cash Flow Analysis
    fcf_vals = [item.free_cash_flow for item in financial_line_items if item.free_cash_flow]
    if fcf_vals and len(fcf_vals) &gt;= 2:
        # Check FCF growth and consistency
        fcf_growth = (fcf_vals[-1] - fcf_vals[0]) / abs(fcf_vals[0])
        positive_fcf_count = sum(1 for f in fcf_vals if f &gt; 0)

        if fcf_growth &gt; 0.3 and positive_fcf_count == len(fcf_vals):
            score += 3
            details.append(&quot;Strong and consistent FCF growth, excellent innovation funding capacity&quot;)
        elif positive_fcf_count &gt;= len(fcf_vals) * 0.75:
            score += 2
            details.append(&quot;Consistent positive FCF, good innovation funding capacity&quot;)
        elif positive_fcf_count &gt; len(fcf_vals) * 0.5:
            score += 1
            details.append(&quot;Moderately consistent FCF, adequate innovation funding capacity&quot;)
    else:
        details.append(&quot;Insufficient FCF data for analysis&quot;)

    # 3. Operating Efficiency Analysis
    op_margin_vals = [item.operating_margin for item in financial_line_items if item.operating_margin]
    if op_margin_vals and len(op_margin_vals) &gt;= 2:
        # Check margin improvement
        margin_trend = op_margin_vals[-1] - op_margin_vals[0]

        if op_margin_vals[-1] &gt; 0.15 and margin_trend &gt; 0:
            score += 3
            details.append(f&quot;Strong and improving operating margin: {(op_margin_vals[-1]*100):.1f}%&quot;)
        elif op_margin_vals[-1] &gt; 0.10:
            score += 2
            details.append(f&quot;Healthy operating margin: {(op_margin_vals[-1]*100):.1f}%&quot;)
        elif margin_trend &gt; 0:
            score += 1
            details.append(&quot;Improving operating efficiency&quot;)
    else:
        details.append(&quot;Insufficient operating margin data&quot;)

    # 4. Capital Allocation Analysis
    capex = [item.capital_expenditure for item in financial_line_items if hasattr(item, &apos;capital_expenditure&apos;) and item.capital_expenditure]
    if capex and revenues and len(capex) &gt;= 2:
        capex_intensity = abs(capex[-1]) / revenues[-1]
        capex_growth = (abs(capex[-1]) - abs(capex[0])) / abs(capex[0]) if capex[0] != 0 else 0

        if capex_intensity &gt; 0.10 and capex_growth &gt; 0.2:
            score += 2
            details.append(&quot;Strong investment in growth infrastructure&quot;)
        elif capex_intensity &gt; 0.05:
            score += 1
            details.append(&quot;Moderate investment in growth infrastructure&quot;)
    else:
        details.append(&quot;Insufficient CAPEX data&quot;)

    # 5. Growth Reinvestment Analysis
    dividends = [item.dividends_and_other_cash_distributions for item in financial_line_items if hasattr(item, &apos;dividends_and_other_cash_distributions&apos;) and item.dividends_and_other_cash_distributions]
    if dividends and fcf_vals:
        # Check if company prioritizes reinvestment over dividends
        latest_payout_ratio = dividends[-1] / fcf_vals[-1] if fcf_vals[-1] != 0 else 1
        if latest_payout_ratio &lt; 0.2:  # Low dividend payout ratio suggests reinvestment focus
            score += 2
            details.append(&quot;Strong focus on reinvestment over dividends&quot;)
        elif latest_payout_ratio &lt; 0.4:
            score += 1
            details.append(&quot;Moderate focus on reinvestment over dividends&quot;)
    else:
        details.append(&quot;Insufficient dividend data&quot;)

    # Normalize score to be out of 5
    max_possible_score = 15  # Sum of all possible points
    normalized_score = (score / max_possible_score) * 5

    return {
        &quot;score&quot;: normalized_score,
        &quot;details&quot;: &quot;; &quot;.join(details),
        &quot;raw_score&quot;: score,
        &quot;max_score&quot;: max_possible_score
    }


def analyze_cathie_wood_valuation(financial_line_items: list, market_cap: float) -&gt; dict:
    &quot;&quot;&quot;
    Cathie Wood often focuses on long-term exponential growth potential. We can do
    a simplified approach looking for a large total addressable market (TAM) and the
    company&apos;s ability to capture a sizable portion.
    &quot;&quot;&quot;
    if not financial_line_items or market_cap is None:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data for valuation&quot;
        }

    latest = financial_line_items[-1]
    fcf = latest.free_cash_flow if latest.free_cash_flow else 0

    if fcf &lt;= 0:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: f&quot;No positive FCF for valuation; FCF = {fcf}&quot;,
            &quot;intrinsic_value&quot;: None
        }

    # Instead of a standard DCF, let&apos;s assume a higher growth rate for an innovative company.
    # Example values:
    growth_rate = 0.20  # 20% annual growth
    discount_rate = 0.15
    terminal_multiple = 25
    projection_years = 5

    present_value = 0
    for year in range(1, projection_years + 1):
        future_fcf = fcf * (1 + growth_rate) ** year
        pv = future_fcf / ((1 + discount_rate) ** year)
        present_value += pv

    # Terminal Value
    terminal_value = (fcf * (1 + growth_rate) ** projection_years * terminal_multiple) \
                     / ((1 + discount_rate) ** projection_years)
    intrinsic_value = present_value + terminal_value

    margin_of_safety = (intrinsic_value - market_cap) / market_cap

    score = 0
    if margin_of_safety &gt; 0.5:
        score += 3
    elif margin_of_safety &gt; 0.2:
        score += 1

    details = [
        f&quot;Calculated intrinsic value: ~{intrinsic_value:,.2f}&quot;,
        f&quot;Market cap: ~{market_cap:,.2f}&quot;,
        f&quot;Margin of safety: {margin_of_safety:.2%}&quot;
    ]

    return {
        &quot;score&quot;: score,
        &quot;details&quot;: &quot;; &quot;.join(details),
        &quot;intrinsic_value&quot;: intrinsic_value,
        &quot;margin_of_safety&quot;: margin_of_safety
    }


def generate_cathie_wood_output(
    ticker: str,
    analysis_data: dict[str, any],
    model_name: str,
    model_provider: str,
) -&gt; CathieWoodSignal:
    &quot;&quot;&quot;
    Generates investment decisions in the style of Cathie Wood.
    &quot;&quot;&quot;
    template = ChatPromptTemplate.from_messages([
        (
            &quot;system&quot;,
            &quot;&quot;&quot;You are a Cathie Wood AI agent, making investment decisions using her principles:\n\n&quot;
            &quot;1. Seek companies leveraging disruptive innovation.\n&quot;
            &quot;2. Emphasize exponential growth potential, large TAM.\n&quot;
            &quot;3. Focus on technology, healthcare, or other future-facing sectors.\n&quot;
            &quot;4. Consider multi-year time horizons for potential breakthroughs.\n&quot;
            &quot;5. Accept higher volatility in pursuit of high returns.\n&quot;
            &quot;6. Evaluate management&apos;s vision and ability to invest in R&amp;D.\n\n&quot;
            &quot;Rules:\n&quot;
            &quot;- Identify disruptive or breakthrough technology.\n&quot;
            &quot;- Evaluate strong potential for multi-year revenue growth.\n&quot;
            &quot;- Check if the company can scale effectively in a large market.\n&quot;
            &quot;- Use a growth-biased valuation approach.\n&quot;
            &quot;- Provide a data-driven recommendation (bullish, bearish, or neutral).&quot;&quot;&quot;
        ),
        (
            &quot;human&quot;,
            &quot;&quot;&quot;Based on the following analysis, create a Cathie Wood-style investment signal.\n\n&quot;
            &quot;Analysis Data for {ticker}:\n&quot;
            &quot;{analysis_data}\n\n&quot;
            &quot;Return the trading signal in this JSON format:\n&quot;
            &quot;{{\n  \&quot;signal\&quot;: \&quot;bullish/bearish/neutral\&quot;,\n  \&quot;confidence\&quot;: float (0-100),\n  \&quot;reasoning\&quot;: \&quot;string\&quot;\n}}&quot;&quot;&quot;
        )
    ])

    prompt = template.invoke({
        &quot;analysis_data&quot;: json.dumps(analysis_data, indent=2),
        &quot;ticker&quot;: ticker
    })

    def create_default_cathie_wood_signal():
        return CathieWoodSignal(
            signal=&quot;neutral&quot;,
            confidence=0.0,
            reasoning=&quot;Error in analysis, defaulting to neutral&quot;
        )

    return call_llm(
        prompt=prompt,
        model_name=model_name,
        model_provider=model_provider,
        pydantic_model=CathieWoodSignal,
        agent_name=&quot;cathie_wood_agent&quot;,
        default_factory=create_default_cathie_wood_signal,
    )

# source: https://ark-invest.com</file><file path="src/agents/charlie_munger.py">from graph.state import AgentState, show_agent_reasoning
from tools.api import get_financial_metrics, get_market_cap, search_line_items, get_insider_trades, get_company_news
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
import json
from typing_extensions import Literal
from utils.progress import progress
from utils.llm import call_llm

class CharlieMungerSignal(BaseModel):
    signal: Literal[&quot;bullish&quot;, &quot;bearish&quot;, &quot;neutral&quot;]
    confidence: float
    reasoning: str


def charlie_munger_agent(state: AgentState):
    &quot;&quot;&quot;
    Analyzes stocks using Charlie Munger&apos;s investing principles and mental models.
    Focuses on moat strength, management quality, predictability, and valuation.
    &quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]
    
    analysis_data = {}
    munger_analysis = {}
    
    for ticker in tickers:
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)
        metrics = get_financial_metrics(ticker, end_date, period=&quot;annual&quot;, limit=10)  # Munger looks at longer periods
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Gathering financial line items&quot;)
        financial_line_items = search_line_items(
            ticker,
            [
                &quot;revenue&quot;,
                &quot;net_income&quot;,
                &quot;operating_income&quot;,
                &quot;return_on_invested_capital&quot;,
                &quot;gross_margin&quot;,
                &quot;operating_margin&quot;,
                &quot;free_cash_flow&quot;,
                &quot;capital_expenditure&quot;,
                &quot;cash_and_equivalents&quot;,
                &quot;total_debt&quot;,
                &quot;shareholders_equity&quot;,
                &quot;outstanding_shares&quot;,
                &quot;research_and_development&quot;,
                &quot;goodwill_and_intangible_assets&quot;,
            ],
            end_date,
            period=&quot;annual&quot;,
            limit=10  # Munger examines long-term trends
        )
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Getting market cap&quot;)
        market_cap = get_market_cap(ticker, end_date)
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Fetching insider trades&quot;)
        # Munger values management with skin in the game
        insider_trades = get_insider_trades(
            ticker,
            end_date,
            # Look back 2 years for insider trading patterns
            start_date=None,
            limit=100
        )
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Fetching company news&quot;)
        # Munger avoids businesses with frequent negative press
        company_news = get_company_news(
            ticker,
            end_date,
            # Look back 1 year for news
            start_date=None,
            limit=100
        )
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Analyzing moat strength&quot;)
        moat_analysis = analyze_moat_strength(metrics, financial_line_items)
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Analyzing management quality&quot;)
        management_analysis = analyze_management_quality(financial_line_items, insider_trades)
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Analyzing business predictability&quot;)
        predictability_analysis = analyze_predictability(financial_line_items)
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Calculating Munger-style valuation&quot;)
        valuation_analysis = calculate_munger_valuation(financial_line_items, market_cap)
        
        # Combine partial scores with Munger&apos;s weighting preferences
        # Munger weights quality and predictability higher than current valuation
        total_score = (
            moat_analysis[&quot;score&quot;] * 0.35 +
            management_analysis[&quot;score&quot;] * 0.25 +
            predictability_analysis[&quot;score&quot;] * 0.25 +
            valuation_analysis[&quot;score&quot;] * 0.15
        )
        
        max_possible_score = 10  # Scale to 0-10
        
        # Generate a simple buy/hold/sell signal
        if total_score &gt;= 7.5:  # Munger has very high standards
            signal = &quot;bullish&quot;
        elif total_score &lt;= 4.5:
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;
        
        analysis_data[ticker] = {
            &quot;signal&quot;: signal,
            &quot;score&quot;: total_score,
            &quot;max_score&quot;: max_possible_score,
            &quot;moat_analysis&quot;: moat_analysis,
            &quot;management_analysis&quot;: management_analysis,
            &quot;predictability_analysis&quot;: predictability_analysis,
            &quot;valuation_analysis&quot;: valuation_analysis,
            # Include some qualitative assessment from news
            &quot;news_sentiment&quot;: analyze_news_sentiment(company_news) if company_news else &quot;No news data available&quot;
        }
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Generating Munger analysis&quot;)
        munger_output = generate_munger_output(
            ticker=ticker, 
            analysis_data=analysis_data,
            model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
            model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
        )
        
        munger_analysis[ticker] = {
            &quot;signal&quot;: munger_output.signal,
            &quot;confidence&quot;: munger_output.confidence,
            &quot;reasoning&quot;: munger_output.reasoning
        }
        
        progress.update_status(&quot;charlie_munger_agent&quot;, ticker, &quot;Done&quot;)
    
    # Wrap results in a single message for the chain
    message = HumanMessage(
        content=json.dumps(munger_analysis),
        name=&quot;charlie_munger_agent&quot;
    )
    
    # Show reasoning if requested
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(munger_analysis, &quot;Charlie Munger Agent&quot;)
    
    # Add signals to the overall state
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;charlie_munger_agent&quot;] = munger_analysis

    return {
        &quot;messages&quot;: [message],
        &quot;data&quot;: state[&quot;data&quot;]
    }


def analyze_moat_strength(metrics: list, financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Analyze the business&apos;s competitive advantage using Munger&apos;s approach:
    - Consistent high returns on capital (ROIC)
    - Pricing power (stable/improving gross margins)
    - Low capital requirements
    - Network effects and intangible assets (R&amp;D investments, goodwill)
    &quot;&quot;&quot;
    score = 0
    details = []
    
    if not metrics or not financial_line_items:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze moat strength&quot;
        }
    
    # 1. Return on Invested Capital (ROIC) analysis - Munger&apos;s favorite metric
    roic_values = [item.return_on_invested_capital for item in financial_line_items 
                   if hasattr(item, &apos;return_on_invested_capital&apos;) and item.return_on_invested_capital is not None]
    
    if roic_values:
        # Check if ROIC consistently above 15% (Munger&apos;s threshold)
        high_roic_count = sum(1 for r in roic_values if r &gt; 0.15)
        if high_roic_count &gt;= len(roic_values) * 0.8:  # 80% of periods show high ROIC
            score += 3
            details.append(f&quot;Excellent ROIC: &gt;15% in {high_roic_count}/{len(roic_values)} periods&quot;)
        elif high_roic_count &gt;= len(roic_values) * 0.5:  # 50% of periods
            score += 2
            details.append(f&quot;Good ROIC: &gt;15% in {high_roic_count}/{len(roic_values)} periods&quot;)
        elif high_roic_count &gt; 0:
            score += 1
            details.append(f&quot;Mixed ROIC: &gt;15% in only {high_roic_count}/{len(roic_values)} periods&quot;)
        else:
            details.append(&quot;Poor ROIC: Never exceeds 15% threshold&quot;)
    else:
        details.append(&quot;No ROIC data available&quot;)
    
    # 2. Pricing power - check gross margin stability and trends
    gross_margins = [item.gross_margin for item in financial_line_items 
                    if hasattr(item, &apos;gross_margin&apos;) and item.gross_margin is not None]
    
    if gross_margins and len(gross_margins) &gt;= 3:
        # Munger likes stable or improving gross margins
        margin_trend = sum(1 for i in range(1, len(gross_margins)) if gross_margins[i] &gt;= gross_margins[i-1])
        if margin_trend &gt;= len(gross_margins) * 0.7:  # Improving in 70% of periods
            score += 2
            details.append(&quot;Strong pricing power: Gross margins consistently improving&quot;)
        elif sum(gross_margins) / len(gross_margins) &gt; 0.3:  # Average margin &gt; 30%
            score += 1
            details.append(f&quot;Good pricing power: Average gross margin {sum(gross_margins)/len(gross_margins):.1%}&quot;)
        else:
            details.append(&quot;Limited pricing power: Low or declining gross margins&quot;)
    else:
        details.append(&quot;Insufficient gross margin data&quot;)
    
    # 3. Capital intensity - Munger prefers low capex businesses
    if len(financial_line_items) &gt;= 3:
        capex_to_revenue = []
        for item in financial_line_items:
            if (hasattr(item, &apos;capital_expenditure&apos;) and item.capital_expenditure is not None and 
                hasattr(item, &apos;revenue&apos;) and item.revenue is not None and item.revenue &gt; 0):
                # Note: capital_expenditure is typically negative in financial statements
                capex_ratio = abs(item.capital_expenditure) / item.revenue
                capex_to_revenue.append(capex_ratio)
        
        if capex_to_revenue:
            avg_capex_ratio = sum(capex_to_revenue) / len(capex_to_revenue)
            if avg_capex_ratio &lt; 0.05:  # Less than 5% of revenue
                score += 2
                details.append(f&quot;Low capital requirements: Avg capex {avg_capex_ratio:.1%} of revenue&quot;)
            elif avg_capex_ratio &lt; 0.10:  # Less than 10% of revenue
                score += 1
                details.append(f&quot;Moderate capital requirements: Avg capex {avg_capex_ratio:.1%} of revenue&quot;)
            else:
                details.append(f&quot;High capital requirements: Avg capex {avg_capex_ratio:.1%} of revenue&quot;)
        else:
            details.append(&quot;No capital expenditure data available&quot;)
    else:
        details.append(&quot;Insufficient data for capital intensity analysis&quot;)
    
    # 4. Intangible assets - Munger values R&amp;D and intellectual property
    r_and_d = [item.research_and_development for item in financial_line_items
              if hasattr(item, &apos;research_and_development&apos;) and item.research_and_development is not None]
    
    goodwill_and_intangible_assets = [item.goodwill_and_intangible_assets for item in financial_line_items
               if hasattr(item, &apos;goodwill_and_intangible_assets&apos;) and item.goodwill_and_intangible_assets is not None]

    if r_and_d and len(r_and_d) &gt; 0:
        if sum(r_and_d) &gt; 0:  # If company is investing in R&amp;D
            score += 1
            details.append(&quot;Invests in R&amp;D, building intellectual property&quot;)
    
    if (goodwill_and_intangible_assets and len(goodwill_and_intangible_assets) &gt; 0):
        score += 1
        details.append(&quot;Significant goodwill/intangible assets, suggesting brand value or IP&quot;)
    
    # Scale score to 0-10 range
    final_score = min(10, score * 10 / 9)  # Max possible raw score is 9
    
    return {
        &quot;score&quot;: final_score,
        &quot;details&quot;: &quot;; &quot;.join(details)
    }


def analyze_management_quality(financial_line_items: list, insider_trades: list) -&gt; dict:
    &quot;&quot;&quot;
    Evaluate management quality using Munger&apos;s criteria:
    - Capital allocation wisdom
    - Insider ownership and transactions
    - Cash management efficiency
    - Candor and transparency
    - Long-term focus
    &quot;&quot;&quot;
    score = 0
    details = []
    
    if not financial_line_items:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze management quality&quot;
        }
    
    # 1. Capital allocation - Check FCF to net income ratio
    # Munger values companies that convert earnings to cash
    fcf_values = [item.free_cash_flow for item in financial_line_items 
                 if hasattr(item, &apos;free_cash_flow&apos;) and item.free_cash_flow is not None]
    
    net_income_values = [item.net_income for item in financial_line_items 
                        if hasattr(item, &apos;net_income&apos;) and item.net_income is not None]
    
    if fcf_values and net_income_values and len(fcf_values) == len(net_income_values):
        # Calculate FCF to Net Income ratio for each period
        fcf_to_ni_ratios = []
        for i in range(len(fcf_values)):
            if net_income_values[i] and net_income_values[i] &gt; 0:
                fcf_to_ni_ratios.append(fcf_values[i] / net_income_values[i])
        
        if fcf_to_ni_ratios:
            avg_ratio = sum(fcf_to_ni_ratios) / len(fcf_to_ni_ratios)
            if avg_ratio &gt; 1.1:  # FCF &gt; net income suggests good accounting
                score += 3
                details.append(f&quot;Excellent cash conversion: FCF/NI ratio of {avg_ratio:.2f}&quot;)
            elif avg_ratio &gt; 0.9:  # FCF roughly equals net income
                score += 2
                details.append(f&quot;Good cash conversion: FCF/NI ratio of {avg_ratio:.2f}&quot;)
            elif avg_ratio &gt; 0.7:  # FCF somewhat lower than net income
                score += 1
                details.append(f&quot;Moderate cash conversion: FCF/NI ratio of {avg_ratio:.2f}&quot;)
            else:
                details.append(f&quot;Poor cash conversion: FCF/NI ratio of only {avg_ratio:.2f}&quot;)
        else:
            details.append(&quot;Could not calculate FCF to Net Income ratios&quot;)
    else:
        details.append(&quot;Missing FCF or Net Income data&quot;)
    
    # 2. Debt management - Munger is cautious about debt
    debt_values = [item.total_debt for item in financial_line_items 
                  if hasattr(item, &apos;total_debt&apos;) and item.total_debt is not None]
    
    equity_values = [item.shareholders_equity for item in financial_line_items 
                    if hasattr(item, &apos;shareholders_equity&apos;) and item.shareholders_equity is not None]
    
    if debt_values and equity_values and len(debt_values) == len(equity_values):
        # Calculate D/E ratio for most recent period
        recent_de_ratio = debt_values[0] / equity_values[0] if equity_values[0] &gt; 0 else float(&apos;inf&apos;)
        
        if recent_de_ratio &lt; 0.3:  # Very low debt
            score += 3
            details.append(f&quot;Conservative debt management: D/E ratio of {recent_de_ratio:.2f}&quot;)
        elif recent_de_ratio &lt; 0.7:  # Moderate debt
            score += 2
            details.append(f&quot;Prudent debt management: D/E ratio of {recent_de_ratio:.2f}&quot;)
        elif recent_de_ratio &lt; 1.5:  # Higher but still reasonable debt
            score += 1
            details.append(f&quot;Moderate debt level: D/E ratio of {recent_de_ratio:.2f}&quot;)
        else:
            details.append(f&quot;High debt level: D/E ratio of {recent_de_ratio:.2f}&quot;)
    else:
        details.append(&quot;Missing debt or equity data&quot;)
    
    # 3. Cash management efficiency - Munger values appropriate cash levels
    cash_values = [item.cash_and_equivalents for item in financial_line_items
                  if hasattr(item, &apos;cash_and_equivalents&apos;) and item.cash_and_equivalents is not None]
    revenue_values = [item.revenue for item in financial_line_items
                     if hasattr(item, &apos;revenue&apos;) and item.revenue is not None]
    
    if cash_values and revenue_values and len(cash_values) &gt; 0 and len(revenue_values) &gt; 0:
        # Calculate cash to revenue ratio (Munger likes 10-20% for most businesses)
        cash_to_revenue = cash_values[0] / revenue_values[0] if revenue_values[0] &gt; 0 else 0
        
        if 0.1 &lt;= cash_to_revenue &lt;= 0.25:
            # Goldilocks zone - not too much, not too little
            score += 2
            details.append(f&quot;Prudent cash management: Cash/Revenue ratio of {cash_to_revenue:.2f}&quot;)
        elif 0.05 &lt;= cash_to_revenue &lt; 0.1 or 0.25 &lt; cash_to_revenue &lt;= 0.4:
            # Reasonable but not ideal
            score += 1
            details.append(f&quot;Acceptable cash position: Cash/Revenue ratio of {cash_to_revenue:.2f}&quot;)
        elif cash_to_revenue &gt; 0.4:
            # Too much cash - potentially inefficient capital allocation
            details.append(f&quot;Excess cash reserves: Cash/Revenue ratio of {cash_to_revenue:.2f}&quot;)
        else:
            # Too little cash - potentially risky
            details.append(f&quot;Low cash reserves: Cash/Revenue ratio of {cash_to_revenue:.2f}&quot;)
    else:
        details.append(&quot;Insufficient cash or revenue data&quot;)
    
    # 4. Insider activity - Munger values skin in the game
    if insider_trades and len(insider_trades) &gt; 0:
        # Count buys vs. sells
        buys = sum(1 for trade in insider_trades if hasattr(trade, &apos;transaction_type&apos;) and 
                   trade.transaction_type and trade.transaction_type.lower() in [&apos;buy&apos;, &apos;purchase&apos;])
        sells = sum(1 for trade in insider_trades if hasattr(trade, &apos;transaction_type&apos;) and 
                    trade.transaction_type and trade.transaction_type.lower() in [&apos;sell&apos;, &apos;sale&apos;])
        
        # Calculate the buy ratio
        total_trades = buys + sells
        if total_trades &gt; 0:
            buy_ratio = buys / total_trades
            if buy_ratio &gt; 0.7:  # Strong insider buying
                score += 2
                details.append(f&quot;Strong insider buying: {buys}/{total_trades} transactions are purchases&quot;)
            elif buy_ratio &gt; 0.4:  # Balanced insider activity
                score += 1
                details.append(f&quot;Balanced insider trading: {buys}/{total_trades} transactions are purchases&quot;)
            elif buy_ratio &lt; 0.1 and sells &gt; 5:  # Heavy selling
                score -= 1  # Penalty for excessive selling
                details.append(f&quot;Concerning insider selling: {sells}/{total_trades} transactions are sales&quot;)
            else:
                details.append(f&quot;Mixed insider activity: {buys}/{total_trades} transactions are purchases&quot;)
        else:
            details.append(&quot;No recorded insider transactions&quot;)
    else:
        details.append(&quot;No insider trading data available&quot;)
    
    # 5. Consistency in share count - Munger prefers stable/decreasing shares
    share_counts = [item.outstanding_shares for item in financial_line_items
                   if hasattr(item, &apos;outstanding_shares&apos;) and item.outstanding_shares is not None]
    
    if share_counts and len(share_counts) &gt;= 3:
        if share_counts[0] &lt; share_counts[-1] * 0.95:  # 5%+ reduction in shares
            score += 2
            details.append(&quot;Shareholder-friendly: Reducing share count over time&quot;)
        elif share_counts[0] &lt; share_counts[-1] * 1.05:  # Stable share count
            score += 1
            details.append(&quot;Stable share count: Limited dilution&quot;)
        elif share_counts[0] &gt; share_counts[-1] * 1.2:  # &gt;20% dilution
            score -= 1  # Penalty for excessive dilution
            details.append(&quot;Concerning dilution: Share count increased significantly&quot;)
        else:
            details.append(&quot;Moderate share count increase over time&quot;)
    else:
        details.append(&quot;Insufficient share count data&quot;)
    
    # Scale score to 0-10 range
    # Maximum possible raw score would be 12 (3+3+2+2+2)
    final_score = max(0, min(10, score * 10 / 12))
    
    return {
        &quot;score&quot;: final_score,
        &quot;details&quot;: &quot;; &quot;.join(details)
    }


def analyze_predictability(financial_line_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Assess the predictability of the business - Munger strongly prefers businesses
    whose future operations and cashflows are relatively easy to predict.
    &quot;&quot;&quot;
    score = 0
    details = []
    
    if not financial_line_items or len(financial_line_items) &lt; 5:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to analyze business predictability (need 5+ years)&quot;
        }
    
    # 1. Revenue stability and growth
    revenues = [item.revenue for item in financial_line_items 
               if hasattr(item, &apos;revenue&apos;) and item.revenue is not None]
    
    if revenues and len(revenues) &gt;= 5:
        # Calculate year-over-year growth rates
        growth_rates = [(revenues[i] / revenues[i+1] - 1) for i in range(len(revenues)-1)]
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        growth_volatility = sum(abs(r - avg_growth) for r in growth_rates) / len(growth_rates)
        
        if avg_growth &gt; 0.05 and growth_volatility &lt; 0.1:
            # Steady, consistent growth (Munger loves this)
            score += 3
            details.append(f&quot;Highly predictable revenue: {avg_growth:.1%} avg growth with low volatility&quot;)
        elif avg_growth &gt; 0 and growth_volatility &lt; 0.2:
            # Positive but somewhat volatile growth
            score += 2
            details.append(f&quot;Moderately predictable revenue: {avg_growth:.1%} avg growth with some volatility&quot;)
        elif avg_growth &gt; 0:
            # Growing but unpredictable
            score += 1
            details.append(f&quot;Growing but less predictable revenue: {avg_growth:.1%} avg growth with high volatility&quot;)
        else:
            details.append(f&quot;Declining or highly unpredictable revenue: {avg_growth:.1%} avg growth&quot;)
    else:
        details.append(&quot;Insufficient revenue history for predictability analysis&quot;)
    
    # 2. Operating income stability
    op_income = [item.operating_income for item in financial_line_items 
                if hasattr(item, &apos;operating_income&apos;) and item.operating_income is not None]
    
    if op_income and len(op_income) &gt;= 5:
        # Count positive operating income periods
        positive_periods = sum(1 for income in op_income if income &gt; 0)
        
        if positive_periods == len(op_income):
            # Consistently profitable operations
            score += 3
            details.append(&quot;Highly predictable operations: Operating income positive in all periods&quot;)
        elif positive_periods &gt;= len(op_income) * 0.8:
            # Mostly profitable operations
            score += 2
            details.append(f&quot;Predictable operations: Operating income positive in {positive_periods}/{len(op_income)} periods&quot;)
        elif positive_periods &gt;= len(op_income) * 0.6:
            # Somewhat profitable operations
            score += 1
            details.append(f&quot;Somewhat predictable operations: Operating income positive in {positive_periods}/{len(op_income)} periods&quot;)
        else:
            details.append(f&quot;Unpredictable operations: Operating income positive in only {positive_periods}/{len(op_income)} periods&quot;)
    else:
        details.append(&quot;Insufficient operating income history&quot;)
    
    # 3. Margin consistency - Munger values stable margins
    op_margins = [item.operating_margin for item in financial_line_items 
                 if hasattr(item, &apos;operating_margin&apos;) and item.operating_margin is not None]
    
    if op_margins and len(op_margins) &gt;= 5:
        # Calculate margin volatility
        avg_margin = sum(op_margins) / len(op_margins)
        margin_volatility = sum(abs(m - avg_margin) for m in op_margins) / len(op_margins)
        
        if margin_volatility &lt; 0.03:  # Very stable margins
            score += 2
            details.append(f&quot;Highly predictable margins: {avg_margin:.1%} avg with minimal volatility&quot;)
        elif margin_volatility &lt; 0.07:  # Moderately stable margins
            score += 1
            details.append(f&quot;Moderately predictable margins: {avg_margin:.1%} avg with some volatility&quot;)
        else:
            details.append(f&quot;Unpredictable margins: {avg_margin:.1%} avg with high volatility ({margin_volatility:.1%})&quot;)
    else:
        details.append(&quot;Insufficient margin history&quot;)
    
    # 4. Cash generation reliability
    fcf_values = [item.free_cash_flow for item in financial_line_items 
                 if hasattr(item, &apos;free_cash_flow&apos;) and item.free_cash_flow is not None]
    
    if fcf_values and len(fcf_values) &gt;= 5:
        # Count positive FCF periods
        positive_fcf_periods = sum(1 for fcf in fcf_values if fcf &gt; 0)
        
        if positive_fcf_periods == len(fcf_values):
            # Consistently positive FCF
            score += 2
            details.append(&quot;Highly predictable cash generation: Positive FCF in all periods&quot;)
        elif positive_fcf_periods &gt;= len(fcf_values) * 0.8:
            # Mostly positive FCF
            score += 1
            details.append(f&quot;Predictable cash generation: Positive FCF in {positive_fcf_periods}/{len(fcf_values)} periods&quot;)
        else:
            details.append(f&quot;Unpredictable cash generation: Positive FCF in only {positive_fcf_periods}/{len(fcf_values)} periods&quot;)
    else:
        details.append(&quot;Insufficient free cash flow history&quot;)
    
    # Scale score to 0-10 range
    # Maximum possible raw score would be 10 (3+3+2+2)
    final_score = min(10, score * 10 / 10)
    
    return {
        &quot;score&quot;: final_score,
        &quot;details&quot;: &quot;; &quot;.join(details)
    }


def calculate_munger_valuation(financial_line_items: list, market_cap: float) -&gt; dict:
    &quot;&quot;&quot;
    Calculate intrinsic value using Munger&apos;s approach:
    - Focus on owner earnings (approximated by FCF)
    - Simple multiple on normalized earnings
    - Prefer paying a fair price for a wonderful business
    &quot;&quot;&quot;
    score = 0
    details = []
    
    if not financial_line_items or market_cap is None:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient data to perform valuation&quot;
        }
    
    # Get FCF values (Munger&apos;s preferred &quot;owner earnings&quot; metric)
    fcf_values = [item.free_cash_flow for item in financial_line_items 
                 if hasattr(item, &apos;free_cash_flow&apos;) and item.free_cash_flow is not None]
    
    if not fcf_values or len(fcf_values) &lt; 3:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: &quot;Insufficient free cash flow data for valuation&quot;
        }
    
    # 1. Normalize earnings by taking average of last 3-5 years
    # (Munger prefers to normalize earnings to avoid over/under-valuation based on cyclical factors)
    normalized_fcf = sum(fcf_values[:min(5, len(fcf_values))]) / min(5, len(fcf_values))
    
    if normalized_fcf &lt;= 0:
        return {
            &quot;score&quot;: 0,
            &quot;details&quot;: f&quot;Negative or zero normalized FCF ({normalized_fcf}), cannot value&quot;,
            &quot;intrinsic_value&quot;: None
        }
    
    # 2. Calculate FCF yield (inverse of P/FCF multiple)
    fcf_yield = normalized_fcf / market_cap
    
    # 3. Apply Munger&apos;s FCF multiple based on business quality
    # Munger would pay higher multiples for wonderful businesses
    # Let&apos;s use a sliding scale where higher FCF yields are more attractive
    if fcf_yield &gt; 0.08:  # &gt;8% FCF yield (P/FCF &lt; 12.5x)
        score += 4
        details.append(f&quot;Excellent value: {fcf_yield:.1%} FCF yield&quot;)
    elif fcf_yield &gt; 0.05:  # &gt;5% FCF yield (P/FCF &lt; 20x)
        score += 3
        details.append(f&quot;Good value: {fcf_yield:.1%} FCF yield&quot;)
    elif fcf_yield &gt; 0.03:  # &gt;3% FCF yield (P/FCF &lt; 33x)
        score += 1
        details.append(f&quot;Fair value: {fcf_yield:.1%} FCF yield&quot;)
    else:
        details.append(f&quot;Expensive: Only {fcf_yield:.1%} FCF yield&quot;)
    
    # 4. Calculate simple intrinsic value range
    # Munger tends to use straightforward valuations, avoiding complex DCF models
    conservative_value = normalized_fcf * 10  # 10x FCF = 10% yield
    reasonable_value = normalized_fcf * 15    # 15x FCF â‰ˆ 6.7% yield
    optimistic_value = normalized_fcf * 20    # 20x FCF = 5% yield
    
    # 5. Calculate margins of safety
    current_to_reasonable = (reasonable_value - market_cap) / market_cap
    
    if current_to_reasonable &gt; 0.3:  # &gt;30% upside
        score += 3
        details.append(f&quot;Large margin of safety: {current_to_reasonable:.1%} upside to reasonable value&quot;)
    elif current_to_reasonable &gt; 0.1:  # &gt;10% upside
        score += 2
        details.append(f&quot;Moderate margin of safety: {current_to_reasonable:.1%} upside to reasonable value&quot;)
    elif current_to_reasonable &gt; -0.1:  # Within 10% of reasonable value
        score += 1
        details.append(f&quot;Fair price: Within 10% of reasonable value ({current_to_reasonable:.1%})&quot;)
    else:
        details.append(f&quot;Expensive: {-current_to_reasonable:.1%} premium to reasonable value&quot;)
    
    # 6. Check earnings trajectory for additional context
    # Munger likes growing owner earnings
    if len(fcf_values) &gt;= 3:
        recent_avg = sum(fcf_values[:3]) / 3
        older_avg = sum(fcf_values[-3:]) / 3 if len(fcf_values) &gt;= 6 else fcf_values[-1]
        
        if recent_avg &gt; older_avg * 1.2:  # &gt;20% growth in FCF
            score += 3
            details.append(&quot;Growing FCF trend adds to intrinsic value&quot;)
        elif recent_avg &gt; older_avg:
            score += 2
            details.append(&quot;Stable to growing FCF supports valuation&quot;)
        else:
            details.append(&quot;Declining FCF trend is concerning&quot;)
    
    # Scale score to 0-10 range
    # Maximum possible raw score would be 10 (4+3+3)
    final_score = min(10, score * 10 / 10) 
    
    return {
        &quot;score&quot;: final_score,
        &quot;details&quot;: &quot;; &quot;.join(details),
        &quot;intrinsic_value_range&quot;: {
            &quot;conservative&quot;: conservative_value,
            &quot;reasonable&quot;: reasonable_value,
            &quot;optimistic&quot;: optimistic_value
        },
        &quot;fcf_yield&quot;: fcf_yield,
        &quot;normalized_fcf&quot;: normalized_fcf
    }


def analyze_news_sentiment(news_items: list) -&gt; str:
    &quot;&quot;&quot;
    Simple qualitative analysis of recent news.
    Munger pays attention to significant news but doesn&apos;t overreact to short-term stories.
    &quot;&quot;&quot;
    if not news_items or len(news_items) == 0:
        return &quot;No news data available&quot;
    
    # Just return a simple count for now - in a real implementation, this would use NLP
    return f&quot;Qualitative review of {len(news_items)} recent news items would be needed&quot;


def generate_munger_output(
    ticker: str,
    analysis_data: dict[str, any],
    model_name: str,
    model_provider: str,
) -&gt; CharlieMungerSignal:
    &quot;&quot;&quot;
    Generates investment decisions in the style of Charlie Munger.
    &quot;&quot;&quot;
    template = ChatPromptTemplate.from_messages([
        (
            &quot;system&quot;,
            &quot;&quot;&quot;You are a Charlie Munger AI agent, making investment decisions using his principles:

            1. Focus on the quality and predictability of the business.
            2. Rely on mental models from multiple disciplines to analyze investments.
            3. Look for strong, durable competitive advantages (moats).
            4. Emphasize long-term thinking and patience.
            5. Value management integrity and competence.
            6. Prioritize businesses with high returns on invested capital.
            7. Pay a fair price for wonderful businesses.
            8. Never overpay, always demand a margin of safety.
            9. Avoid complexity and businesses you don&apos;t understand.
            10. &quot;Invert, always invert&quot; - focus on avoiding stupidity rather than seeking brilliance.
            
            Rules:
            - Praise businesses with predictable, consistent operations and cash flows.
            - Value businesses with high ROIC and pricing power.
            - Prefer simple businesses with understandable economics.
            - Admire management with skin in the game and shareholder-friendly capital allocation.
            - Focus on long-term economics rather than short-term metrics.
            - Be skeptical of businesses with rapidly changing dynamics or excessive share dilution.
            - Avoid excessive leverage or financial engineering.
            - Provide a rational, data-driven recommendation (bullish, bearish, or neutral).&quot;&quot;&quot;
        ),
        (
            &quot;human&quot;,
            &quot;&quot;&quot;Based on the following analysis, create a Munger-style investment signal.

            Analysis Data for {ticker}:
            {analysis_data}

            Return the trading signal in this JSON format:
            {{
              &quot;signal&quot;: &quot;bullish/bearish/neutral&quot;,
              &quot;confidence&quot;: float (0-100),
              &quot;reasoning&quot;: &quot;string&quot;
            }}
            &quot;&quot;&quot;
        )
    ])

    prompt = template.invoke({
        &quot;analysis_data&quot;: json.dumps(analysis_data, indent=2),
        &quot;ticker&quot;: ticker
    })

    def create_default_charlie_munger_signal():
        return CharlieMungerSignal(
            signal=&quot;neutral&quot;,
            confidence=0.0,
            reasoning=&quot;Error in analysis, defaulting to neutral&quot;
        )

    return call_llm(
        prompt=prompt, 
        model_name=model_name, 
        model_provider=model_provider, 
        pydantic_model=CharlieMungerSignal, 
        agent_name=&quot;charlie_munger_agent&quot;, 
        default_factory=create_default_charlie_munger_signal,
    )</file><file path="src/agents/fundamentals.py">from langchain_core.messages import HumanMessage
from graph.state import AgentState, show_agent_reasoning
from utils.progress import progress
import json

from tools.api import get_financial_metrics


##### Fundamental Agent #####
def fundamentals_agent(state: AgentState):
    &quot;&quot;&quot;Analyzes fundamental data and generates trading signals for multiple tickers.&quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    # Initialize fundamental analysis for each ticker
    fundamental_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)

        # Get the financial metrics
        financial_metrics = get_financial_metrics(
            ticker=ticker,
            end_date=end_date,
            period=&quot;ttm&quot;,
            limit=10,
        )

        if not financial_metrics:
            progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Failed: No financial metrics found&quot;)
            continue

        # Pull the most recent financial metrics
        metrics = financial_metrics[0]

        # Initialize signals list for different fundamental aspects
        signals = []
        reasoning = {}

        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Analyzing profitability&quot;)
        # 1. Profitability Analysis
        return_on_equity = metrics.return_on_equity
        net_margin = metrics.net_margin
        operating_margin = metrics.operating_margin

        thresholds = [
            (return_on_equity, 0.15),  # Strong ROE above 15%
            (net_margin, 0.20),  # Healthy profit margins
            (operating_margin, 0.15),  # Strong operating efficiency
        ]
        profitability_score = sum(metric is not None and metric &gt; threshold for metric, threshold in thresholds)

        signals.append(&quot;bullish&quot; if profitability_score &gt;= 2 else &quot;bearish&quot; if profitability_score == 0 else &quot;neutral&quot;)
        reasoning[&quot;profitability_signal&quot;] = {
            &quot;signal&quot;: signals[0],
            &quot;details&quot;: (f&quot;ROE: {return_on_equity:.2%}&quot; if return_on_equity else &quot;ROE: N/A&quot;) + &quot;, &quot; + (f&quot;Net Margin: {net_margin:.2%}&quot; if net_margin else &quot;Net Margin: N/A&quot;) + &quot;, &quot; + (f&quot;Op Margin: {operating_margin:.2%}&quot; if operating_margin else &quot;Op Margin: N/A&quot;),
        }

        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Analyzing growth&quot;)
        # 2. Growth Analysis
        revenue_growth = metrics.revenue_growth
        earnings_growth = metrics.earnings_growth
        book_value_growth = metrics.book_value_growth

        thresholds = [
            (revenue_growth, 0.10),  # 10% revenue growth
            (earnings_growth, 0.10),  # 10% earnings growth
            (book_value_growth, 0.10),  # 10% book value growth
        ]
        growth_score = sum(metric is not None and metric &gt; threshold for metric, threshold in thresholds)

        signals.append(&quot;bullish&quot; if growth_score &gt;= 2 else &quot;bearish&quot; if growth_score == 0 else &quot;neutral&quot;)
        reasoning[&quot;growth_signal&quot;] = {
            &quot;signal&quot;: signals[1],
            &quot;details&quot;: (f&quot;Revenue Growth: {revenue_growth:.2%}&quot; if revenue_growth else &quot;Revenue Growth: N/A&quot;) + &quot;, &quot; + (f&quot;Earnings Growth: {earnings_growth:.2%}&quot; if earnings_growth else &quot;Earnings Growth: N/A&quot;),
        }

        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Analyzing financial health&quot;)
        # 3. Financial Health
        current_ratio = metrics.current_ratio
        debt_to_equity = metrics.debt_to_equity
        free_cash_flow_per_share = metrics.free_cash_flow_per_share
        earnings_per_share = metrics.earnings_per_share

        health_score = 0
        if current_ratio and current_ratio &gt; 1.5:  # Strong liquidity
            health_score += 1
        if debt_to_equity and debt_to_equity &lt; 0.5:  # Conservative debt levels
            health_score += 1
        if free_cash_flow_per_share and earnings_per_share and free_cash_flow_per_share &gt; earnings_per_share * 0.8:  # Strong FCF conversion
            health_score += 1

        signals.append(&quot;bullish&quot; if health_score &gt;= 2 else &quot;bearish&quot; if health_score == 0 else &quot;neutral&quot;)
        reasoning[&quot;financial_health_signal&quot;] = {
            &quot;signal&quot;: signals[2],
            &quot;details&quot;: (f&quot;Current Ratio: {current_ratio:.2f}&quot; if current_ratio else &quot;Current Ratio: N/A&quot;) + &quot;, &quot; + (f&quot;D/E: {debt_to_equity:.2f}&quot; if debt_to_equity else &quot;D/E: N/A&quot;),
        }

        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Analyzing valuation ratios&quot;)
        # 4. Price to X ratios
        pe_ratio = metrics.price_to_earnings_ratio
        pb_ratio = metrics.price_to_book_ratio
        ps_ratio = metrics.price_to_sales_ratio

        thresholds = [
            (pe_ratio, 25),  # Reasonable P/E ratio
            (pb_ratio, 3),  # Reasonable P/B ratio
            (ps_ratio, 5),  # Reasonable P/S ratio
        ]
        price_ratio_score = sum(metric is not None and metric &gt; threshold for metric, threshold in thresholds)

        signals.append(&quot;bullish&quot; if price_ratio_score &gt;= 2 else &quot;bearish&quot; if price_ratio_score == 0 else &quot;neutral&quot;)
        reasoning[&quot;price_ratios_signal&quot;] = {
            &quot;signal&quot;: signals[3],
            &quot;details&quot;: (f&quot;P/E: {pe_ratio:.2f}&quot; if pe_ratio else &quot;P/E: N/A&quot;) + &quot;, &quot; + (f&quot;P/B: {pb_ratio:.2f}&quot; if pb_ratio else &quot;P/B: N/A&quot;) + &quot;, &quot; + (f&quot;P/S: {ps_ratio:.2f}&quot; if ps_ratio else &quot;P/S: N/A&quot;),
        }

        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Calculating final signal&quot;)
        # Determine overall signal
        bullish_signals = signals.count(&quot;bullish&quot;)
        bearish_signals = signals.count(&quot;bearish&quot;)

        if bullish_signals &gt; bearish_signals:
            overall_signal = &quot;bullish&quot;
        elif bearish_signals &gt; bullish_signals:
            overall_signal = &quot;bearish&quot;
        else:
            overall_signal = &quot;neutral&quot;

        # Calculate confidence level
        total_signals = len(signals)
        confidence = round(max(bullish_signals, bearish_signals) / total_signals, 2) * 100

        fundamental_analysis[ticker] = {
            &quot;signal&quot;: overall_signal,
            &quot;confidence&quot;: confidence,
            &quot;reasoning&quot;: reasoning,
        }

        progress.update_status(&quot;fundamentals_agent&quot;, ticker, &quot;Done&quot;)

    # Create the fundamental analysis message
    message = HumanMessage(
        content=json.dumps(fundamental_analysis),
        name=&quot;fundamentals_agent&quot;,
    )

    # Print the reasoning if the flag is set
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(fundamental_analysis, &quot;Fundamental Analysis Agent&quot;)

    # Add the signal to the analyst_signals list
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;fundamentals_agent&quot;] = fundamental_analysis

    return {
        &quot;messages&quot;: [message],
        &quot;data&quot;: data,
    }</file><file path="src/agents/portfolio_manager.py">import json
from langchain_core.messages import HumanMessage
from langchain_core.prompts import ChatPromptTemplate

from graph.state import AgentState, show_agent_reasoning
from pydantic import BaseModel, Field
from typing_extensions import Literal
from utils.progress import progress
from utils.llm import call_llm


class PortfolioDecision(BaseModel):
    action: Literal[&quot;buy&quot;, &quot;sell&quot;, &quot;short&quot;, &quot;cover&quot;, &quot;hold&quot;]
    quantity: int = Field(description=&quot;Number of shares to trade&quot;)
    confidence: float = Field(description=&quot;Confidence in the decision, between 0.0 and 100.0&quot;)
    reasoning: str = Field(description=&quot;Reasoning for the decision&quot;)


class PortfolioManagerOutput(BaseModel):
    decisions: dict[str, PortfolioDecision] = Field(description=&quot;Dictionary of ticker to trading decisions&quot;)


##### Portfolio Management Agent #####
def portfolio_management_agent(state: AgentState):
    &quot;&quot;&quot;Makes final trading decisions and generates orders for multiple tickers&quot;&quot;&quot;

    # Get the portfolio and analyst signals
    portfolio = state[&quot;data&quot;][&quot;portfolio&quot;]
    analyst_signals = state[&quot;data&quot;][&quot;analyst_signals&quot;]
    tickers = state[&quot;data&quot;][&quot;tickers&quot;]

    progress.update_status(&quot;portfolio_management_agent&quot;, None, &quot;Analyzing signals&quot;)

    # Get position limits, current prices, and signals for every ticker
    position_limits = {}
    current_prices = {}
    max_shares = {}
    signals_by_ticker = {}
    for ticker in tickers:
        progress.update_status(&quot;portfolio_management_agent&quot;, ticker, &quot;Processing analyst signals&quot;)

        # Get position limits and current prices for the ticker
        risk_data = analyst_signals.get(&quot;risk_management_agent&quot;, {}).get(ticker, {})
        position_limits[ticker] = risk_data.get(&quot;remaining_position_limit&quot;, 0)
        current_prices[ticker] = risk_data.get(&quot;current_price&quot;, 0)

        # Calculate maximum shares allowed based on position limit and price
        if current_prices[ticker] &gt; 0:
            max_shares[ticker] = int(position_limits[ticker] / current_prices[ticker])
        else:
            max_shares[ticker] = 0

        # Get signals for the ticker
        ticker_signals = {}
        for agent, signals in analyst_signals.items():
            if agent != &quot;risk_management_agent&quot; and ticker in signals:
                ticker_signals[agent] = {&quot;signal&quot;: signals[ticker][&quot;signal&quot;], &quot;confidence&quot;: signals[ticker][&quot;confidence&quot;]}
        signals_by_ticker[ticker] = ticker_signals

    progress.update_status(&quot;portfolio_management_agent&quot;, None, &quot;Making trading decisions&quot;)

    # Generate the trading decision
    result = generate_trading_decision(
        tickers=tickers,
        signals_by_ticker=signals_by_ticker,
        current_prices=current_prices,
        max_shares=max_shares,
        portfolio=portfolio,
        model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
        model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
    )

    # Create the portfolio management message
    message = HumanMessage(
        content=json.dumps({ticker: decision.model_dump() for ticker, decision in result.decisions.items()}),
        name=&quot;portfolio_management&quot;,
    )

    # Print the decision if the flag is set
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning({ticker: decision.model_dump() for ticker, decision in result.decisions.items()}, &quot;Portfolio Management Agent&quot;)

    progress.update_status(&quot;portfolio_management_agent&quot;, None, &quot;Done&quot;)

    return {
        &quot;messages&quot;: state[&quot;messages&quot;] + [message],
        &quot;data&quot;: state[&quot;data&quot;],
    }


def generate_trading_decision(
    tickers: list[str],
    signals_by_ticker: dict[str, dict],
    current_prices: dict[str, float],
    max_shares: dict[str, int],
    portfolio: dict[str, float],
    model_name: str,
    model_provider: str,
) -&gt; PortfolioManagerOutput:
    &quot;&quot;&quot;Attempts to get a decision from the LLM with retry logic&quot;&quot;&quot;
    # Create the prompt template
    template = ChatPromptTemplate.from_messages(
        [
            (
              &quot;system&quot;,
              &quot;&quot;&quot;You are a portfolio manager making final trading decisions based on multiple tickers.

              Trading Rules:
              - For long positions:
                * Only buy if you have available cash
                * Only sell if you currently hold long shares of that ticker
                * Sell quantity must be â‰¤ current long position shares
                * Buy quantity must be â‰¤ max_shares for that ticker
              
              - For short positions:
                * Only short if you have available margin (50% of position value required)
                * Only cover if you currently have short shares of that ticker
                * Cover quantity must be â‰¤ current short position shares
                * Short quantity must respect margin requirements
              
              - The max_shares values are pre-calculated to respect position limits
              - Consider both long and short opportunities based on signals
              - Maintain appropriate risk management with both long and short exposure

              Available Actions:
              - &quot;buy&quot;: Open or add to long position
              - &quot;sell&quot;: Close or reduce long position
              - &quot;short&quot;: Open or add to short position
              - &quot;cover&quot;: Close or reduce short position
              - &quot;hold&quot;: No action

              Inputs:
              - signals_by_ticker: dictionary of ticker â†’ signals
              - max_shares: maximum shares allowed per ticker
              - portfolio_cash: current cash in portfolio
              - portfolio_positions: current positions (both long and short)
              - current_prices: current prices for each ticker
              - margin_requirement: current margin requirement for short positions
              &quot;&quot;&quot;,
            ),
            (
              &quot;human&quot;,
              &quot;&quot;&quot;Based on the team&apos;s analysis, make your trading decisions for each ticker.

              Here are the signals by ticker:
              {signals_by_ticker}

              Current Prices:
              {current_prices}

              Maximum Shares Allowed For Purchases:
              {max_shares}

              Portfolio Cash: {portfolio_cash}
              Current Positions: {portfolio_positions}
              Current Margin Requirement: {margin_requirement}

              Output strictly in JSON with the following structure:
              {{
                &quot;decisions&quot;: {{
                  &quot;TICKER1&quot;: {{
                    &quot;action&quot;: &quot;buy/sell/short/cover/hold&quot;,
                    &quot;quantity&quot;: integer,
                    &quot;confidence&quot;: float between 0 and 100,
                    &quot;reasoning&quot;: &quot;string&quot;
                  }},
                  &quot;TICKER2&quot;: {{
                    ...
                  }},
                  ...
                }}
              }}
              &quot;&quot;&quot;,
            ),
        ]
    )

    # Generate the prompt
    prompt = template.invoke(
        {
            &quot;signals_by_ticker&quot;: json.dumps(signals_by_ticker, indent=2),
            &quot;current_prices&quot;: json.dumps(current_prices, indent=2),
            &quot;max_shares&quot;: json.dumps(max_shares, indent=2),
            &quot;portfolio_cash&quot;: f&quot;{portfolio.get(&apos;cash&apos;, 0):.2f}&quot;,
            &quot;portfolio_positions&quot;: json.dumps(portfolio.get(&apos;positions&apos;, {}), indent=2),
            &quot;margin_requirement&quot;: f&quot;{portfolio.get(&apos;margin_requirement&apos;, 0):.2f}&quot;,
        }
    )

    # Create default factory for PortfolioManagerOutput
    def create_default_portfolio_output():
        return PortfolioManagerOutput(decisions={ticker: PortfolioDecision(action=&quot;hold&quot;, quantity=0, confidence=0.0, reasoning=&quot;Error in portfolio management, defaulting to hold&quot;) for ticker in tickers})

    return call_llm(prompt=prompt, model_name=model_name, model_provider=model_provider, pydantic_model=PortfolioManagerOutput, agent_name=&quot;portfolio_management_agent&quot;, default_factory=create_default_portfolio_output)</file><file path="src/agents/risk_manager.py">from langchain_core.messages import HumanMessage
from graph.state import AgentState, show_agent_reasoning
from utils.progress import progress
from tools.api import get_prices, prices_to_df
import json


##### Risk Management Agent #####
def risk_management_agent(state: AgentState):
    &quot;&quot;&quot;Controls position sizing based on real-world risk factors for multiple tickers.&quot;&quot;&quot;
    portfolio = state[&quot;data&quot;][&quot;portfolio&quot;]
    data = state[&quot;data&quot;]
    tickers = data[&quot;tickers&quot;]

    # Initialize risk analysis for each ticker
    risk_analysis = {}
    current_prices = {}  # Store prices here to avoid redundant API calls

    for ticker in tickers:
        progress.update_status(&quot;risk_management_agent&quot;, ticker, &quot;Analyzing price data&quot;)

        prices = get_prices(
            ticker=ticker,
            start_date=data[&quot;start_date&quot;],
            end_date=data[&quot;end_date&quot;],
        )

        if not prices:
            progress.update_status(&quot;risk_management_agent&quot;, ticker, &quot;Failed: No price data found&quot;)
            continue

        prices_df = prices_to_df(prices)

        progress.update_status(&quot;risk_management_agent&quot;, ticker, &quot;Calculating position limits&quot;)

        # Calculate portfolio value
        current_price = prices_df[&quot;close&quot;].iloc[-1]
        current_prices[ticker] = current_price  # Store the current price

        # Calculate current position value for this ticker
        current_position_value = portfolio.get(&quot;cost_basis&quot;, {}).get(ticker, 0)

        # Calculate total portfolio value using stored prices
        total_portfolio_value = portfolio.get(&quot;cash&quot;, 0) + sum(portfolio.get(&quot;cost_basis&quot;, {}).get(t, 0) for t in portfolio.get(&quot;cost_basis&quot;, {}))

        # Base limit is 20% of portfolio for any single position
        position_limit = total_portfolio_value * 0.20

        # For existing positions, subtract current position value from limit
        remaining_position_limit = position_limit - current_position_value

        # Ensure we don&apos;t exceed available cash
        max_position_size = min(remaining_position_limit, portfolio.get(&quot;cash&quot;, 0))

        risk_analysis[ticker] = {
            &quot;remaining_position_limit&quot;: float(max_position_size),
            &quot;current_price&quot;: float(current_price),
            &quot;reasoning&quot;: {
                &quot;portfolio_value&quot;: float(total_portfolio_value),
                &quot;current_position&quot;: float(current_position_value),
                &quot;position_limit&quot;: float(position_limit),
                &quot;remaining_limit&quot;: float(remaining_position_limit),
                &quot;available_cash&quot;: float(portfolio.get(&quot;cash&quot;, 0)),
            },
        }

        progress.update_status(&quot;risk_management_agent&quot;, ticker, &quot;Done&quot;)

    message = HumanMessage(
        content=json.dumps(risk_analysis),
        name=&quot;risk_management_agent&quot;,
    )

    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(risk_analysis, &quot;Risk Management Agent&quot;)

    # Add the signal to the analyst_signals list
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;risk_management_agent&quot;] = risk_analysis

    return {
        &quot;messages&quot;: state[&quot;messages&quot;] + [message],
        &quot;data&quot;: data,
    }</file><file path="src/agents/sentiment.py">from langchain_core.messages import HumanMessage
from graph.state import AgentState, show_agent_reasoning
from utils.progress import progress
import pandas as pd
import numpy as np
import json

from tools.api import get_insider_trades, get_company_news


##### Sentiment Agent #####
def sentiment_agent(state: AgentState):
    &quot;&quot;&quot;Analyzes market sentiment and generates trading signals for multiple tickers.&quot;&quot;&quot;
    data = state.get(&quot;data&quot;, {})
    end_date = data.get(&quot;end_date&quot;)
    tickers = data.get(&quot;tickers&quot;)

    # Initialize sentiment analysis for each ticker
    sentiment_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;sentiment_agent&quot;, ticker, &quot;Fetching insider trades&quot;)

        # Get the insider trades
        insider_trades = get_insider_trades(
            ticker=ticker,
            end_date=end_date,
            limit=1000,
        )

        progress.update_status(&quot;sentiment_agent&quot;, ticker, &quot;Analyzing trading patterns&quot;)

        # Get the signals from the insider trades
        transaction_shares = pd.Series([t.transaction_shares for t in insider_trades]).dropna()
        insider_signals = np.where(transaction_shares &lt; 0, &quot;bearish&quot;, &quot;bullish&quot;).tolist()

        progress.update_status(&quot;sentiment_agent&quot;, ticker, &quot;Fetching company news&quot;)

        # Get the company news
        company_news = get_company_news(ticker, end_date, limit=100)

        # Get the sentiment from the company news
        sentiment = pd.Series([n.sentiment for n in company_news]).dropna()
        news_signals = np.where(sentiment == &quot;negative&quot;, &quot;bearish&quot;, 
                              np.where(sentiment == &quot;positive&quot;, &quot;bullish&quot;, &quot;neutral&quot;)).tolist()
        
        progress.update_status(&quot;sentiment_agent&quot;, ticker, &quot;Combining signals&quot;)
        # Combine signals from both sources with weights
        insider_weight = 0.3
        news_weight = 0.7
        
        # Calculate weighted signal counts
        bullish_signals = (
            insider_signals.count(&quot;bullish&quot;) * insider_weight +
            news_signals.count(&quot;bullish&quot;) * news_weight
        )
        bearish_signals = (
            insider_signals.count(&quot;bearish&quot;) * insider_weight +
            news_signals.count(&quot;bearish&quot;) * news_weight
        )

        if bullish_signals &gt; bearish_signals:
            overall_signal = &quot;bullish&quot;
        elif bearish_signals &gt; bullish_signals:
            overall_signal = &quot;bearish&quot;
        else:
            overall_signal = &quot;neutral&quot;

        # Calculate confidence level based on the weighted proportion
        total_weighted_signals = len(insider_signals) * insider_weight + len(news_signals) * news_weight
        confidence = 0  # Default confidence when there are no signals
        if total_weighted_signals &gt; 0:
            confidence = round(max(bullish_signals, bearish_signals) / total_weighted_signals, 2) * 100
        reasoning = f&quot;Weighted Bullish signals: {bullish_signals:.1f}, Weighted Bearish signals: {bearish_signals:.1f}&quot;

        sentiment_analysis[ticker] = {
            &quot;signal&quot;: overall_signal,
            &quot;confidence&quot;: confidence,
            &quot;reasoning&quot;: reasoning,
        }

        progress.update_status(&quot;sentiment_agent&quot;, ticker, &quot;Done&quot;)

    # Create the sentiment message
    message = HumanMessage(
        content=json.dumps(sentiment_analysis),
        name=&quot;sentiment_agent&quot;,
    )

    # Print the reasoning if the flag is set
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(sentiment_analysis, &quot;Sentiment Analysis Agent&quot;)

    # Add the signal to the analyst_signals list
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;sentiment_agent&quot;] = sentiment_analysis

    return {
        &quot;messages&quot;: [message],
        &quot;data&quot;: data,
    }</file><file path="src/agents/stanley_druckenmiller.py">from graph.state import AgentState, show_agent_reasoning
from tools.api import (
    get_financial_metrics,
    get_market_cap,
    search_line_items,
    get_insider_trades,
    get_company_news,
    get_prices,
)
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
import json
from typing_extensions import Literal
from utils.progress import progress
from utils.llm import call_llm
import statistics


class StanleyDruckenmillerSignal(BaseModel):
    signal: Literal[&quot;bullish&quot;, &quot;bearish&quot;, &quot;neutral&quot;]
    confidence: float
    reasoning: str


def stanley_druckenmiller_agent(state: AgentState):
    &quot;&quot;&quot;
    Analyzes stocks using Stanley Druckenmiller&apos;s investing principles:
      - Seeking asymmetric risk-reward opportunities
      - Emphasizing growth, momentum, and sentiment
      - Willing to be aggressive if conditions are favorable
      - Focus on preserving capital by avoiding high-risk, low-reward bets

    Returns a bullish/bearish/neutral signal with confidence and reasoning.
    &quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    analysis_data = {}
    druck_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)
        metrics = get_financial_metrics(ticker, end_date, period=&quot;annual&quot;, limit=5)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Gathering financial line items&quot;)
        # Include relevant line items for Stan Druckenmiller&apos;s approach:
        #   - Growth &amp; momentum: revenue, EPS, operating_income, ...
        #   - Valuation: net_income, free_cash_flow, ebit, ebitda
        #   - Leverage: total_debt, shareholders_equity
        #   - Liquidity: cash_and_equivalents
        financial_line_items = search_line_items(
            ticker,
            [
                &quot;revenue&quot;,
                &quot;earnings_per_share&quot;,
                &quot;net_income&quot;,
                &quot;operating_income&quot;,
                &quot;gross_margin&quot;,
                &quot;operating_margin&quot;,
                &quot;free_cash_flow&quot;,
                &quot;capital_expenditure&quot;,
                &quot;cash_and_equivalents&quot;,
                &quot;total_debt&quot;,
                &quot;shareholders_equity&quot;,
                &quot;outstanding_shares&quot;,
                &quot;ebit&quot;,
                &quot;ebitda&quot;,
            ],
            end_date,
            period=&quot;annual&quot;,
            limit=5,
        )

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Getting market cap&quot;)
        market_cap = get_market_cap(ticker, end_date)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Fetching insider trades&quot;)
        insider_trades = get_insider_trades(ticker, end_date, start_date=None, limit=50)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Fetching company news&quot;)
        company_news = get_company_news(ticker, end_date, start_date=None, limit=50)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Fetching recent price data for momentum&quot;)
        # Fetch ~1 year of daily prices for momentum/trend analysis
        prices = get_prices(ticker, start_date=&quot;2022-01-01&quot;, end_date=end_date)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Analyzing growth &amp; momentum&quot;)
        growth_momentum_analysis = analyze_growth_and_momentum(financial_line_items, prices)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Analyzing sentiment&quot;)
        sentiment_analysis = analyze_sentiment(company_news)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Analyzing insider activity&quot;)
        insider_activity = analyze_insider_activity(insider_trades)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Analyzing risk-reward&quot;)
        risk_reward_analysis = analyze_risk_reward(financial_line_items, market_cap, prices)

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Performing Druckenmiller-style valuation&quot;)
        valuation_analysis = analyze_druckenmiller_valuation(financial_line_items, market_cap)

        # Combine partial scores with weights typical for Druckenmiller:
        #   35% Growth/Momentum, 20% Risk/Reward, 20% Valuation,
        #   15% Sentiment, 10% Insider Activity = 100%
        total_score = (
            growth_momentum_analysis[&quot;score&quot;] * 0.35
            + risk_reward_analysis[&quot;score&quot;] * 0.20
            + valuation_analysis[&quot;score&quot;] * 0.20
            + sentiment_analysis[&quot;score&quot;] * 0.15
            + insider_activity[&quot;score&quot;] * 0.10
        )

        max_possible_score = 10

        # Simple bullish/neutral/bearish signal
        if total_score &gt;= 7.5:
            signal = &quot;bullish&quot;
        elif total_score &lt;= 4.5:
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;

        analysis_data[ticker] = {
            &quot;signal&quot;: signal,
            &quot;score&quot;: total_score,
            &quot;max_score&quot;: max_possible_score,
            &quot;growth_momentum_analysis&quot;: growth_momentum_analysis,
            &quot;sentiment_analysis&quot;: sentiment_analysis,
            &quot;insider_activity&quot;: insider_activity,
            &quot;risk_reward_analysis&quot;: risk_reward_analysis,
            &quot;valuation_analysis&quot;: valuation_analysis,
        }

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Generating Druckenmiller analysis&quot;)
        druck_output = generate_druckenmiller_output(
            ticker=ticker,
            analysis_data=analysis_data,
            model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
            model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
        )

        druck_analysis[ticker] = {
            &quot;signal&quot;: druck_output.signal,
            &quot;confidence&quot;: druck_output.confidence,
            &quot;reasoning&quot;: druck_output.reasoning,
        }

        progress.update_status(&quot;stanley_druckenmiller_agent&quot;, ticker, &quot;Done&quot;)

    # Wrap results in a single message
    message = HumanMessage(content=json.dumps(druck_analysis), name=&quot;stanley_druckenmiller_agent&quot;)

    if state[&quot;metadata&quot;].get(&quot;show_reasoning&quot;):
        show_agent_reasoning(druck_analysis, &quot;Stanley Druckenmiller Agent&quot;)

    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;stanley_druckenmiller_agent&quot;] = druck_analysis
    return {&quot;messages&quot;: [message], &quot;data&quot;: state[&quot;data&quot;]}


def analyze_growth_and_momentum(financial_line_items: list, prices: list) -&gt; dict:
    &quot;&quot;&quot;
    Evaluate:
      - Revenue Growth (YoY)
      - EPS Growth (YoY)
      - Price Momentum
    &quot;&quot;&quot;
    if not financial_line_items or len(financial_line_items) &lt; 2:
        return {&quot;score&quot;: 0, &quot;details&quot;: &quot;Insufficient financial data for growth analysis&quot;}

    details = []
    raw_score = 0  # We&apos;ll sum up a maximum of 9 raw points, then scale to 0â€“10

    #
    # 1. Revenue Growth
    #
    revenues = [fi.revenue for fi in financial_line_items if fi.revenue is not None]
    if len(revenues) &gt;= 2:
        latest_rev = revenues[0]
        older_rev = revenues[-1]
        if older_rev &gt; 0:
            rev_growth = (latest_rev - older_rev) / abs(older_rev)
            if rev_growth &gt; 0.30:
                raw_score += 3
                details.append(f&quot;Strong revenue growth: {rev_growth:.1%}&quot;)
            elif rev_growth &gt; 0.15:
                raw_score += 2
                details.append(f&quot;Moderate revenue growth: {rev_growth:.1%}&quot;)
            elif rev_growth &gt; 0.05:
                raw_score += 1
                details.append(f&quot;Slight revenue growth: {rev_growth:.1%}&quot;)
            else:
                details.append(f&quot;Minimal/negative revenue growth: {rev_growth:.1%}&quot;)
        else:
            details.append(&quot;Older revenue is zero/negative; can&apos;t compute revenue growth.&quot;)
    else:
        details.append(&quot;Not enough revenue data points for growth calculation.&quot;)

    #
    # 2. EPS Growth
    #
    eps_values = [fi.earnings_per_share for fi in financial_line_items if fi.earnings_per_share is not None]
    if len(eps_values) &gt;= 2:
        latest_eps = eps_values[0]
        older_eps = eps_values[-1]
        # Avoid division by zero
        if abs(older_eps) &gt; 1e-9:
            eps_growth = (latest_eps - older_eps) / abs(older_eps)
            if eps_growth &gt; 0.30:
                raw_score += 3
                details.append(f&quot;Strong EPS growth: {eps_growth:.1%}&quot;)
            elif eps_growth &gt; 0.15:
                raw_score += 2
                details.append(f&quot;Moderate EPS growth: {eps_growth:.1%}&quot;)
            elif eps_growth &gt; 0.05:
                raw_score += 1
                details.append(f&quot;Slight EPS growth: {eps_growth:.1%}&quot;)
            else:
                details.append(f&quot;Minimal/negative EPS growth: {eps_growth:.1%}&quot;)
        else:
            details.append(&quot;Older EPS is near zero; skipping EPS growth calculation.&quot;)
    else:
        details.append(&quot;Not enough EPS data points for growth calculation.&quot;)

    #
    # 3. Price Momentum
    #
    # We&apos;ll give up to 3 points for strong momentum
    if prices and len(prices) &gt; 30:
        sorted_prices = sorted(prices, key=lambda p: p.time)
        close_prices = [p.close for p in sorted_prices if p.close is not None]
        if len(close_prices) &gt;= 2:
            start_price = close_prices[0]
            end_price = close_prices[-1]
            if start_price &gt; 0:
                pct_change = (end_price - start_price) / start_price
                if pct_change &gt; 0.50:
                    raw_score += 3
                    details.append(f&quot;Very strong price momentum: {pct_change:.1%}&quot;)
                elif pct_change &gt; 0.20:
                    raw_score += 2
                    details.append(f&quot;Moderate price momentum: {pct_change:.1%}&quot;)
                elif pct_change &gt; 0:
                    raw_score += 1
                    details.append(f&quot;Slight positive momentum: {pct_change:.1%}&quot;)
                else:
                    details.append(f&quot;Negative price momentum: {pct_change:.1%}&quot;)
            else:
                details.append(&quot;Invalid start price (&lt;= 0); can&apos;t compute momentum.&quot;)
        else:
            details.append(&quot;Insufficient price data for momentum calculation.&quot;)
    else:
        details.append(&quot;Not enough recent price data for momentum analysis.&quot;)

    # We assigned up to 3 points each for:
    #   revenue growth, eps growth, momentum
    # =&gt; max raw_score = 9
    # Scale to 0â€“10
    final_score = min(10, (raw_score / 9) * 10)

    return {&quot;score&quot;: final_score, &quot;details&quot;: &quot;; &quot;.join(details)}


def analyze_insider_activity(insider_trades: list) -&gt; dict:
    &quot;&quot;&quot;
    Simple insider-trade analysis:
      - If there&apos;s heavy insider buying, we nudge the score up.
      - If there&apos;s mostly selling, we reduce it.
      - Otherwise, neutral.
    &quot;&quot;&quot;
    # Default is neutral (5/10).
    score = 5
    details = []

    if not insider_trades:
        details.append(&quot;No insider trades data; defaulting to neutral&quot;)
        return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}

    buys, sells = 0, 0
    for trade in insider_trades:
        # Use transaction_shares to determine if it&apos;s a buy or sell
        # Negative shares = sell, positive shares = buy
        if trade.transaction_shares is not None:
            if trade.transaction_shares &gt; 0:
                buys += 1
            elif trade.transaction_shares &lt; 0:
                sells += 1

    total = buys + sells
    if total == 0:
        details.append(&quot;No buy/sell transactions found; neutral&quot;)
        return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}

    buy_ratio = buys / total
    if buy_ratio &gt; 0.7:
        # Heavy buying =&gt; +3 points from the neutral 5 =&gt; 8
        score = 8
        details.append(f&quot;Heavy insider buying: {buys} buys vs. {sells} sells&quot;)
    elif buy_ratio &gt; 0.4:
        # Moderate buying =&gt; +1 =&gt; 6
        score = 6
        details.append(f&quot;Moderate insider buying: {buys} buys vs. {sells} sells&quot;)
    else:
        # Low insider buying =&gt; -1 =&gt; 4
        score = 4
        details.append(f&quot;Mostly insider selling: {buys} buys vs. {sells} sells&quot;)

    return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}


def analyze_sentiment(news_items: list) -&gt; dict:
    &quot;&quot;&quot;
    Basic news sentiment: negative keyword check vs. overall volume.
    &quot;&quot;&quot;
    if not news_items:
        return {&quot;score&quot;: 5, &quot;details&quot;: &quot;No news data; defaulting to neutral sentiment&quot;}

    negative_keywords = [&quot;lawsuit&quot;, &quot;fraud&quot;, &quot;negative&quot;, &quot;downturn&quot;, &quot;decline&quot;, &quot;investigation&quot;, &quot;recall&quot;]
    negative_count = 0
    for news in news_items:
        title_lower = (news.title or &quot;&quot;).lower()
        if any(word in title_lower for word in negative_keywords):
            negative_count += 1

    details = []
    if negative_count &gt; len(news_items) * 0.3:
        # More than 30% negative =&gt; somewhat bearish =&gt; 3/10
        score = 3
        details.append(f&quot;High proportion of negative headlines: {negative_count}/{len(news_items)}&quot;)
    elif negative_count &gt; 0:
        # Some negativity =&gt; 6/10
        score = 6
        details.append(f&quot;Some negative headlines: {negative_count}/{len(news_items)}&quot;)
    else:
        # Mostly positive =&gt; 8/10
        score = 8
        details.append(&quot;Mostly positive/neutral headlines&quot;)

    return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(details)}


def analyze_risk_reward(financial_line_items: list, market_cap: float | None, prices: list) -&gt; dict:
    &quot;&quot;&quot;
    Assesses risk via:
      - Debt-to-Equity
      - Price Volatility
    Aims for strong upside with contained downside.
    &quot;&quot;&quot;
    if not financial_line_items or not prices:
        return {&quot;score&quot;: 0, &quot;details&quot;: &quot;Insufficient data for risk-reward analysis&quot;}

    details = []
    raw_score = 0  # We&apos;ll accumulate up to 6 raw points, then scale to 0-10

    #
    # 1. Debt-to-Equity
    #
    debt_values = [fi.total_debt for fi in financial_line_items if fi.total_debt is not None]
    equity_values = [fi.shareholders_equity for fi in financial_line_items if fi.shareholders_equity is not None]

    if debt_values and equity_values and len(debt_values) == len(equity_values) and len(debt_values) &gt; 0:
        recent_debt = debt_values[0]
        recent_equity = equity_values[0] if equity_values[0] else 1e-9
        de_ratio = recent_debt / recent_equity
        if de_ratio &lt; 0.3:
            raw_score += 3
            details.append(f&quot;Low debt-to-equity: {de_ratio:.2f}&quot;)
        elif de_ratio &lt; 0.7:
            raw_score += 2
            details.append(f&quot;Moderate debt-to-equity: {de_ratio:.2f}&quot;)
        elif de_ratio &lt; 1.5:
            raw_score += 1
            details.append(f&quot;Somewhat high debt-to-equity: {de_ratio:.2f}&quot;)
        else:
            details.append(f&quot;High debt-to-equity: {de_ratio:.2f}&quot;)
    else:
        details.append(&quot;No consistent debt/equity data available.&quot;)

    #
    # 2. Price Volatility
    #
    if len(prices) &gt; 10:
        sorted_prices = sorted(prices, key=lambda p: p.time)
        close_prices = [p.close for p in sorted_prices if p.close is not None]
        if len(close_prices) &gt; 10:
            daily_returns = []
            for i in range(1, len(close_prices)):
                prev_close = close_prices[i - 1]
                if prev_close &gt; 0:
                    daily_returns.append((close_prices[i] - prev_close) / prev_close)
            if daily_returns:
                stdev = statistics.pstdev(daily_returns)  # population stdev
                if stdev &lt; 0.01:
                    raw_score += 3
                    details.append(f&quot;Low volatility: daily returns stdev {stdev:.2%}&quot;)
                elif stdev &lt; 0.02:
                    raw_score += 2
                    details.append(f&quot;Moderate volatility: daily returns stdev {stdev:.2%}&quot;)
                elif stdev &lt; 0.04:
                    raw_score += 1
                    details.append(f&quot;High volatility: daily returns stdev {stdev:.2%}&quot;)
                else:
                    details.append(f&quot;Very high volatility: daily returns stdev {stdev:.2%}&quot;)
            else:
                details.append(&quot;Insufficient daily returns data for volatility calc.&quot;)
        else:
            details.append(&quot;Not enough close-price data points for volatility analysis.&quot;)
    else:
        details.append(&quot;Not enough price data for volatility analysis.&quot;)

    # raw_score out of 6 =&gt; scale to 0â€“10
    final_score = min(10, (raw_score / 6) * 10)
    return {&quot;score&quot;: final_score, &quot;details&quot;: &quot;; &quot;.join(details)}


def analyze_druckenmiller_valuation(financial_line_items: list, market_cap: float | None) -&gt; dict:
    &quot;&quot;&quot;
    Druckenmiller is willing to pay up for growth, but still checks:
      - P/E
      - P/FCF
      - EV/EBIT
      - EV/EBITDA
    Each can yield up to 2 points =&gt; max 8 raw points =&gt; scale to 0â€“10.
    &quot;&quot;&quot;
    if not financial_line_items or market_cap is None:
        return {&quot;score&quot;: 0, &quot;details&quot;: &quot;Insufficient data to perform valuation&quot;}

    details = []
    raw_score = 0

    # Gather needed data
    net_incomes = [fi.net_income for fi in financial_line_items if fi.net_income is not None]
    fcf_values = [fi.free_cash_flow for fi in financial_line_items if fi.free_cash_flow is not None]
    ebit_values = [fi.ebit for fi in financial_line_items if fi.ebit is not None]
    ebitda_values = [fi.ebitda for fi in financial_line_items if fi.ebitda is not None]

    # For EV calculation, let&apos;s get the most recent total_debt &amp; cash
    debt_values = [fi.total_debt for fi in financial_line_items if fi.total_debt is not None]
    cash_values = [fi.cash_and_equivalents for fi in financial_line_items if fi.cash_and_equivalents is not None]
    recent_debt = debt_values[0] if debt_values else 0
    recent_cash = cash_values[0] if cash_values else 0

    enterprise_value = market_cap + recent_debt - recent_cash

    # 1) P/E
    recent_net_income = net_incomes[0] if net_incomes else None
    if recent_net_income and recent_net_income &gt; 0:
        pe = market_cap / recent_net_income
        pe_points = 0
        if pe &lt; 15:
            pe_points = 2
            details.append(f&quot;Attractive P/E: {pe:.2f}&quot;)
        elif pe &lt; 25:
            pe_points = 1
            details.append(f&quot;Fair P/E: {pe:.2f}&quot;)
        else:
            details.append(f&quot;High or Very high P/E: {pe:.2f}&quot;)
        raw_score += pe_points
    else:
        details.append(&quot;No positive net income for P/E calculation&quot;)

    # 2) P/FCF
    recent_fcf = fcf_values[0] if fcf_values else None
    if recent_fcf and recent_fcf &gt; 0:
        pfcf = market_cap / recent_fcf
        pfcf_points = 0
        if pfcf &lt; 15:
            pfcf_points = 2
            details.append(f&quot;Attractive P/FCF: {pfcf:.2f}&quot;)
        elif pfcf &lt; 25:
            pfcf_points = 1
            details.append(f&quot;Fair P/FCF: {pfcf:.2f}&quot;)
        else:
            details.append(f&quot;High/Very high P/FCF: {pfcf:.2f}&quot;)
        raw_score += pfcf_points
    else:
        details.append(&quot;No positive free cash flow for P/FCF calculation&quot;)

    # 3) EV/EBIT
    recent_ebit = ebit_values[0] if ebit_values else None
    if enterprise_value &gt; 0 and recent_ebit and recent_ebit &gt; 0:
        ev_ebit = enterprise_value / recent_ebit
        ev_ebit_points = 0
        if ev_ebit &lt; 15:
            ev_ebit_points = 2
            details.append(f&quot;Attractive EV/EBIT: {ev_ebit:.2f}&quot;)
        elif ev_ebit &lt; 25:
            ev_ebit_points = 1
            details.append(f&quot;Fair EV/EBIT: {ev_ebit:.2f}&quot;)
        else:
            details.append(f&quot;High EV/EBIT: {ev_ebit:.2f}&quot;)
        raw_score += ev_ebit_points
    else:
        details.append(&quot;No valid EV/EBIT because EV &lt;= 0 or EBIT &lt;= 0&quot;)

    # 4) EV/EBITDA
    recent_ebitda = ebitda_values[0] if ebitda_values else None
    if enterprise_value &gt; 0 and recent_ebitda and recent_ebitda &gt; 0:
        ev_ebitda = enterprise_value / recent_ebitda
        ev_ebitda_points = 0
        if ev_ebitda &lt; 10:
            ev_ebitda_points = 2
            details.append(f&quot;Attractive EV/EBITDA: {ev_ebitda:.2f}&quot;)
        elif ev_ebitda &lt; 18:
            ev_ebitda_points = 1
            details.append(f&quot;Fair EV/EBITDA: {ev_ebitda:.2f}&quot;)
        else:
            details.append(f&quot;High EV/EBITDA: {ev_ebitda:.2f}&quot;)
        raw_score += ev_ebitda_points
    else:
        details.append(&quot;No valid EV/EBITDA because EV &lt;= 0 or EBITDA &lt;= 0&quot;)

    # We have up to 2 points for each of the 4 metrics =&gt; 8 raw points max
    # Scale raw_score to 0â€“10
    final_score = min(10, (raw_score / 8) * 10)

    return {&quot;score&quot;: final_score, &quot;details&quot;: &quot;; &quot;.join(details)}


def generate_druckenmiller_output(
    ticker: str,
    analysis_data: dict[str, any],
    model_name: str,
    model_provider: str,
) -&gt; StanleyDruckenmillerSignal:
    &quot;&quot;&quot;
    Generates a JSON signal in the style of Stanley Druckenmiller.
    &quot;&quot;&quot;
    template = ChatPromptTemplate.from_messages(
        [
            (
                &quot;system&quot;,
                &quot;&quot;&quot;You are a Stanley Druckenmiller AI agent, making investment decisions using his principles:
            
            1. Seek asymmetric risk-reward opportunities (large upside, limited downside).
            2. Emphasize growth, momentum, and market sentiment.
            3. Preserve capital by avoiding major drawdowns.
            4. Willing to pay higher valuations for true growth leaders.
            5. Be aggressive when conviction is high.
            6. Cut losses quickly if the thesis changes.
            
            Rules:
            - Reward companies showing strong revenue/earnings growth and positive stock momentum.
            - Evaluate sentiment and insider activity as supportive or contradictory signals.
            - Watch out for high leverage or extreme volatility that threatens capital.
            - Output a JSON object with signal, confidence, and a reasoning string.
            &quot;&quot;&quot;,
            ),
            (
                &quot;human&quot;,
                &quot;&quot;&quot;Based on the following analysis, create a Druckenmiller-style investment signal.

            Analysis Data for {ticker}:
            {analysis_data}

            Return the trading signal in this JSON format:
            {{
              &quot;signal&quot;: &quot;bullish/bearish/neutral&quot;,
              &quot;confidence&quot;: float (0-100),
              &quot;reasoning&quot;: &quot;string&quot;
            }}
            &quot;&quot;&quot;,
            ),
        ]
    )

    prompt = template.invoke({&quot;analysis_data&quot;: json.dumps(analysis_data, indent=2), &quot;ticker&quot;: ticker})

    def create_default_signal():
        return StanleyDruckenmillerSignal(
            signal=&quot;neutral&quot;,
            confidence=0.0,
            reasoning=&quot;Error in analysis, defaulting to neutral&quot;
        )

    return call_llm(
        prompt=prompt,
        model_name=model_name,
        model_provider=model_provider,
        pydantic_model=StanleyDruckenmillerSignal,
        agent_name=&quot;stanley_druckenmiller_agent&quot;,
        default_factory=create_default_signal,
    )</file><file path="src/agents/technicals.py">import math

from langchain_core.messages import HumanMessage

from graph.state import AgentState, show_agent_reasoning

import json
import pandas as pd
import numpy as np

from tools.api import get_prices, prices_to_df
from utils.progress import progress


##### Technical Analyst #####
def technical_analyst_agent(state: AgentState):
    &quot;&quot;&quot;
    Sophisticated technical analysis system that combines multiple trading strategies for multiple tickers:
    1. Trend Following
    2. Mean Reversion
    3. Momentum
    4. Volatility Analysis
    5. Statistical Arbitrage Signals
    &quot;&quot;&quot;
    data = state[&quot;data&quot;]
    start_date = data[&quot;start_date&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    # Initialize analysis for each ticker
    technical_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Analyzing price data&quot;)

        # Get the historical price data
        prices = get_prices(
            ticker=ticker,
            start_date=start_date,
            end_date=end_date,
        )

        if not prices:
            progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Failed: No price data found&quot;)
            continue

        # Convert prices to a DataFrame
        prices_df = prices_to_df(prices)

        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Calculating trend signals&quot;)
        trend_signals = calculate_trend_signals(prices_df)

        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Calculating mean reversion&quot;)
        mean_reversion_signals = calculate_mean_reversion_signals(prices_df)

        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Calculating momentum&quot;)
        momentum_signals = calculate_momentum_signals(prices_df)

        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Analyzing volatility&quot;)
        volatility_signals = calculate_volatility_signals(prices_df)

        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Statistical analysis&quot;)
        stat_arb_signals = calculate_stat_arb_signals(prices_df)

        # Combine all signals using a weighted ensemble approach
        strategy_weights = {
            &quot;trend&quot;: 0.25,
            &quot;mean_reversion&quot;: 0.20,
            &quot;momentum&quot;: 0.25,
            &quot;volatility&quot;: 0.15,
            &quot;stat_arb&quot;: 0.15,
        }

        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Combining signals&quot;)
        combined_signal = weighted_signal_combination(
            {
                &quot;trend&quot;: trend_signals,
                &quot;mean_reversion&quot;: mean_reversion_signals,
                &quot;momentum&quot;: momentum_signals,
                &quot;volatility&quot;: volatility_signals,
                &quot;stat_arb&quot;: stat_arb_signals,
            },
            strategy_weights,
        )

        # Generate detailed analysis report for this ticker
        technical_analysis[ticker] = {
            &quot;signal&quot;: combined_signal[&quot;signal&quot;],
            &quot;confidence&quot;: round(combined_signal[&quot;confidence&quot;] * 100),
            &quot;strategy_signals&quot;: {
                &quot;trend_following&quot;: {
                    &quot;signal&quot;: trend_signals[&quot;signal&quot;],
                    &quot;confidence&quot;: round(trend_signals[&quot;confidence&quot;] * 100),
                    &quot;metrics&quot;: normalize_pandas(trend_signals[&quot;metrics&quot;]),
                },
                &quot;mean_reversion&quot;: {
                    &quot;signal&quot;: mean_reversion_signals[&quot;signal&quot;],
                    &quot;confidence&quot;: round(mean_reversion_signals[&quot;confidence&quot;] * 100),
                    &quot;metrics&quot;: normalize_pandas(mean_reversion_signals[&quot;metrics&quot;]),
                },
                &quot;momentum&quot;: {
                    &quot;signal&quot;: momentum_signals[&quot;signal&quot;],
                    &quot;confidence&quot;: round(momentum_signals[&quot;confidence&quot;] * 100),
                    &quot;metrics&quot;: normalize_pandas(momentum_signals[&quot;metrics&quot;]),
                },
                &quot;volatility&quot;: {
                    &quot;signal&quot;: volatility_signals[&quot;signal&quot;],
                    &quot;confidence&quot;: round(volatility_signals[&quot;confidence&quot;] * 100),
                    &quot;metrics&quot;: normalize_pandas(volatility_signals[&quot;metrics&quot;]),
                },
                &quot;statistical_arbitrage&quot;: {
                    &quot;signal&quot;: stat_arb_signals[&quot;signal&quot;],
                    &quot;confidence&quot;: round(stat_arb_signals[&quot;confidence&quot;] * 100),
                    &quot;metrics&quot;: normalize_pandas(stat_arb_signals[&quot;metrics&quot;]),
                },
            },
        }
        progress.update_status(&quot;technical_analyst_agent&quot;, ticker, &quot;Done&quot;)

    # Create the technical analyst message
    message = HumanMessage(
        content=json.dumps(technical_analysis),
        name=&quot;technical_analyst_agent&quot;,
    )

    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(technical_analysis, &quot;Technical Analyst&quot;)

    # Add the signal to the analyst_signals list
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;technical_analyst_agent&quot;] = technical_analysis

    return {
        &quot;messages&quot;: state[&quot;messages&quot;] + [message],
        &quot;data&quot;: data,
    }


def calculate_trend_signals(prices_df):
    &quot;&quot;&quot;
    Advanced trend following strategy using multiple timeframes and indicators
    &quot;&quot;&quot;
    # Calculate EMAs for multiple timeframes
    ema_8 = calculate_ema(prices_df, 8)
    ema_21 = calculate_ema(prices_df, 21)
    ema_55 = calculate_ema(prices_df, 55)

    # Calculate ADX for trend strength
    adx = calculate_adx(prices_df, 14)

    # Determine trend direction and strength
    short_trend = ema_8 &gt; ema_21
    medium_trend = ema_21 &gt; ema_55

    # Combine signals with confidence weighting
    trend_strength = adx[&quot;adx&quot;].iloc[-1] / 100.0

    if short_trend.iloc[-1] and medium_trend.iloc[-1]:
        signal = &quot;bullish&quot;
        confidence = trend_strength
    elif not short_trend.iloc[-1] and not medium_trend.iloc[-1]:
        signal = &quot;bearish&quot;
        confidence = trend_strength
    else:
        signal = &quot;neutral&quot;
        confidence = 0.5

    return {
        &quot;signal&quot;: signal,
        &quot;confidence&quot;: confidence,
        &quot;metrics&quot;: {
            &quot;adx&quot;: float(adx[&quot;adx&quot;].iloc[-1]),
            &quot;trend_strength&quot;: float(trend_strength),
        },
    }


def calculate_mean_reversion_signals(prices_df):
    &quot;&quot;&quot;
    Mean reversion strategy using statistical measures and Bollinger Bands
    &quot;&quot;&quot;
    # Calculate z-score of price relative to moving average
    ma_50 = prices_df[&quot;close&quot;].rolling(window=50).mean()
    std_50 = prices_df[&quot;close&quot;].rolling(window=50).std()
    z_score = (prices_df[&quot;close&quot;] - ma_50) / std_50

    # Calculate Bollinger Bands
    bb_upper, bb_lower = calculate_bollinger_bands(prices_df)

    # Calculate RSI with multiple timeframes
    rsi_14 = calculate_rsi(prices_df, 14)
    rsi_28 = calculate_rsi(prices_df, 28)

    # Mean reversion signals
    price_vs_bb = (prices_df[&quot;close&quot;].iloc[-1] - bb_lower.iloc[-1]) / (bb_upper.iloc[-1] - bb_lower.iloc[-1])

    # Combine signals
    if z_score.iloc[-1] &lt; -2 and price_vs_bb &lt; 0.2:
        signal = &quot;bullish&quot;
        confidence = min(abs(z_score.iloc[-1]) / 4, 1.0)
    elif z_score.iloc[-1] &gt; 2 and price_vs_bb &gt; 0.8:
        signal = &quot;bearish&quot;
        confidence = min(abs(z_score.iloc[-1]) / 4, 1.0)
    else:
        signal = &quot;neutral&quot;
        confidence = 0.5

    return {
        &quot;signal&quot;: signal,
        &quot;confidence&quot;: confidence,
        &quot;metrics&quot;: {
            &quot;z_score&quot;: float(z_score.iloc[-1]),
            &quot;price_vs_bb&quot;: float(price_vs_bb),
            &quot;rsi_14&quot;: float(rsi_14.iloc[-1]),
            &quot;rsi_28&quot;: float(rsi_28.iloc[-1]),
        },
    }


def calculate_momentum_signals(prices_df):
    &quot;&quot;&quot;
    Multi-factor momentum strategy
    &quot;&quot;&quot;
    # Price momentum
    returns = prices_df[&quot;close&quot;].pct_change()
    mom_1m = returns.rolling(21).sum()
    mom_3m = returns.rolling(63).sum()
    mom_6m = returns.rolling(126).sum()

    # Volume momentum
    volume_ma = prices_df[&quot;volume&quot;].rolling(21).mean()
    volume_momentum = prices_df[&quot;volume&quot;] / volume_ma

    # Relative strength
    # (would compare to market/sector in real implementation)

    # Calculate momentum score
    momentum_score = (0.4 * mom_1m + 0.3 * mom_3m + 0.3 * mom_6m).iloc[-1]

    # Volume confirmation
    volume_confirmation = volume_momentum.iloc[-1] &gt; 1.0

    if momentum_score &gt; 0.05 and volume_confirmation:
        signal = &quot;bullish&quot;
        confidence = min(abs(momentum_score) * 5, 1.0)
    elif momentum_score &lt; -0.05 and volume_confirmation:
        signal = &quot;bearish&quot;
        confidence = min(abs(momentum_score) * 5, 1.0)
    else:
        signal = &quot;neutral&quot;
        confidence = 0.5

    return {
        &quot;signal&quot;: signal,
        &quot;confidence&quot;: confidence,
        &quot;metrics&quot;: {
            &quot;momentum_1m&quot;: float(mom_1m.iloc[-1]),
            &quot;momentum_3m&quot;: float(mom_3m.iloc[-1]),
            &quot;momentum_6m&quot;: float(mom_6m.iloc[-1]),
            &quot;volume_momentum&quot;: float(volume_momentum.iloc[-1]),
        },
    }


def calculate_volatility_signals(prices_df):
    &quot;&quot;&quot;
    Volatility-based trading strategy
    &quot;&quot;&quot;
    # Calculate various volatility metrics
    returns = prices_df[&quot;close&quot;].pct_change()

    # Historical volatility
    hist_vol = returns.rolling(21).std() * math.sqrt(252)

    # Volatility regime detection
    vol_ma = hist_vol.rolling(63).mean()
    vol_regime = hist_vol / vol_ma

    # Volatility mean reversion
    vol_z_score = (hist_vol - vol_ma) / hist_vol.rolling(63).std()

    # ATR ratio
    atr = calculate_atr(prices_df)
    atr_ratio = atr / prices_df[&quot;close&quot;]

    # Generate signal based on volatility regime
    current_vol_regime = vol_regime.iloc[-1]
    vol_z = vol_z_score.iloc[-1]

    if current_vol_regime &lt; 0.8 and vol_z &lt; -1:
        signal = &quot;bullish&quot;  # Low vol regime, potential for expansion
        confidence = min(abs(vol_z) / 3, 1.0)
    elif current_vol_regime &gt; 1.2 and vol_z &gt; 1:
        signal = &quot;bearish&quot;  # High vol regime, potential for contraction
        confidence = min(abs(vol_z) / 3, 1.0)
    else:
        signal = &quot;neutral&quot;
        confidence = 0.5

    return {
        &quot;signal&quot;: signal,
        &quot;confidence&quot;: confidence,
        &quot;metrics&quot;: {
            &quot;historical_volatility&quot;: float(hist_vol.iloc[-1]),
            &quot;volatility_regime&quot;: float(current_vol_regime),
            &quot;volatility_z_score&quot;: float(vol_z),
            &quot;atr_ratio&quot;: float(atr_ratio.iloc[-1]),
        },
    }


def calculate_stat_arb_signals(prices_df):
    &quot;&quot;&quot;
    Statistical arbitrage signals based on price action analysis
    &quot;&quot;&quot;
    # Calculate price distribution statistics
    returns = prices_df[&quot;close&quot;].pct_change()

    # Skewness and kurtosis
    skew = returns.rolling(63).skew()
    kurt = returns.rolling(63).kurt()

    # Test for mean reversion using Hurst exponent
    hurst = calculate_hurst_exponent(prices_df[&quot;close&quot;])

    # Correlation analysis
    # (would include correlation with related securities in real implementation)

    # Generate signal based on statistical properties
    if hurst &lt; 0.4 and skew.iloc[-1] &gt; 1:
        signal = &quot;bullish&quot;
        confidence = (0.5 - hurst) * 2
    elif hurst &lt; 0.4 and skew.iloc[-1] &lt; -1:
        signal = &quot;bearish&quot;
        confidence = (0.5 - hurst) * 2
    else:
        signal = &quot;neutral&quot;
        confidence = 0.5

    return {
        &quot;signal&quot;: signal,
        &quot;confidence&quot;: confidence,
        &quot;metrics&quot;: {
            &quot;hurst_exponent&quot;: float(hurst),
            &quot;skewness&quot;: float(skew.iloc[-1]),
            &quot;kurtosis&quot;: float(kurt.iloc[-1]),
        },
    }


def weighted_signal_combination(signals, weights):
    &quot;&quot;&quot;
    Combines multiple trading signals using a weighted approach
    &quot;&quot;&quot;
    # Convert signals to numeric values
    signal_values = {&quot;bullish&quot;: 1, &quot;neutral&quot;: 0, &quot;bearish&quot;: -1}

    weighted_sum = 0
    total_confidence = 0

    for strategy, signal in signals.items():
        numeric_signal = signal_values[signal[&quot;signal&quot;]]
        weight = weights[strategy]
        confidence = signal[&quot;confidence&quot;]

        weighted_sum += numeric_signal * weight * confidence
        total_confidence += weight * confidence

    # Normalize the weighted sum
    if total_confidence &gt; 0:
        final_score = weighted_sum / total_confidence
    else:
        final_score = 0

    # Convert back to signal
    if final_score &gt; 0.2:
        signal = &quot;bullish&quot;
    elif final_score &lt; -0.2:
        signal = &quot;bearish&quot;
    else:
        signal = &quot;neutral&quot;

    return {&quot;signal&quot;: signal, &quot;confidence&quot;: abs(final_score)}


def normalize_pandas(obj):
    &quot;&quot;&quot;Convert pandas Series/DataFrames to primitive Python types&quot;&quot;&quot;
    if isinstance(obj, pd.Series):
        return obj.tolist()
    elif isinstance(obj, pd.DataFrame):
        return obj.to_dict(&quot;records&quot;)
    elif isinstance(obj, dict):
        return {k: normalize_pandas(v) for k, v in obj.items()}
    elif isinstance(obj, (list, tuple)):
        return [normalize_pandas(item) for item in obj]
    return obj


def calculate_rsi(prices_df: pd.DataFrame, period: int = 14) -&gt; pd.Series:
    delta = prices_df[&quot;close&quot;].diff()
    gain = (delta.where(delta &gt; 0, 0)).fillna(0)
    loss = (-delta.where(delta &lt; 0, 0)).fillna(0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi


def calculate_bollinger_bands(prices_df: pd.DataFrame, window: int = 20) -&gt; tuple[pd.Series, pd.Series]:
    sma = prices_df[&quot;close&quot;].rolling(window).mean()
    std_dev = prices_df[&quot;close&quot;].rolling(window).std()
    upper_band = sma + (std_dev * 2)
    lower_band = sma - (std_dev * 2)
    return upper_band, lower_band


def calculate_ema(df: pd.DataFrame, window: int) -&gt; pd.Series:
    &quot;&quot;&quot;
    Calculate Exponential Moving Average

    Args:
        df: DataFrame with price data
        window: EMA period

    Returns:
        pd.Series: EMA values
    &quot;&quot;&quot;
    return df[&quot;close&quot;].ewm(span=window, adjust=False).mean()


def calculate_adx(df: pd.DataFrame, period: int = 14) -&gt; pd.DataFrame:
    &quot;&quot;&quot;
    Calculate Average Directional Index (ADX)

    Args:
        df: DataFrame with OHLC data
        period: Period for calculations

    Returns:
        DataFrame with ADX values
    &quot;&quot;&quot;
    # Calculate True Range
    df[&quot;high_low&quot;] = df[&quot;high&quot;] - df[&quot;low&quot;]
    df[&quot;high_close&quot;] = abs(df[&quot;high&quot;] - df[&quot;close&quot;].shift())
    df[&quot;low_close&quot;] = abs(df[&quot;low&quot;] - df[&quot;close&quot;].shift())
    df[&quot;tr&quot;] = df[[&quot;high_low&quot;, &quot;high_close&quot;, &quot;low_close&quot;]].max(axis=1)

    # Calculate Directional Movement
    df[&quot;up_move&quot;] = df[&quot;high&quot;] - df[&quot;high&quot;].shift()
    df[&quot;down_move&quot;] = df[&quot;low&quot;].shift() - df[&quot;low&quot;]

    df[&quot;plus_dm&quot;] = np.where((df[&quot;up_move&quot;] &gt; df[&quot;down_move&quot;]) &amp; (df[&quot;up_move&quot;] &gt; 0), df[&quot;up_move&quot;], 0)
    df[&quot;minus_dm&quot;] = np.where((df[&quot;down_move&quot;] &gt; df[&quot;up_move&quot;]) &amp; (df[&quot;down_move&quot;] &gt; 0), df[&quot;down_move&quot;], 0)

    # Calculate ADX
    df[&quot;+di&quot;] = 100 * (df[&quot;plus_dm&quot;].ewm(span=period).mean() / df[&quot;tr&quot;].ewm(span=period).mean())
    df[&quot;-di&quot;] = 100 * (df[&quot;minus_dm&quot;].ewm(span=period).mean() / df[&quot;tr&quot;].ewm(span=period).mean())
    df[&quot;dx&quot;] = 100 * abs(df[&quot;+di&quot;] - df[&quot;-di&quot;]) / (df[&quot;+di&quot;] + df[&quot;-di&quot;])
    df[&quot;adx&quot;] = df[&quot;dx&quot;].ewm(span=period).mean()

    return df[[&quot;adx&quot;, &quot;+di&quot;, &quot;-di&quot;]]


def calculate_atr(df: pd.DataFrame, period: int = 14) -&gt; pd.Series:
    &quot;&quot;&quot;
    Calculate Average True Range

    Args:
        df: DataFrame with OHLC data
        period: Period for ATR calculation

    Returns:
        pd.Series: ATR values
    &quot;&quot;&quot;
    high_low = df[&quot;high&quot;] - df[&quot;low&quot;]
    high_close = abs(df[&quot;high&quot;] - df[&quot;close&quot;].shift())
    low_close = abs(df[&quot;low&quot;] - df[&quot;close&quot;].shift())

    ranges = pd.concat([high_low, high_close, low_close], axis=1)
    true_range = ranges.max(axis=1)

    return true_range.rolling(period).mean()


def calculate_hurst_exponent(price_series: pd.Series, max_lag: int = 20) -&gt; float:
    &quot;&quot;&quot;
    Calculate Hurst Exponent to determine long-term memory of time series
    H &lt; 0.5: Mean reverting series
    H = 0.5: Random walk
    H &gt; 0.5: Trending series

    Args:
        price_series: Array-like price data
        max_lag: Maximum lag for R/S calculation

    Returns:
        float: Hurst exponent
    &quot;&quot;&quot;
    lags = range(2, max_lag)
    # Add small epsilon to avoid log(0)
    tau = [max(1e-8, np.sqrt(np.std(np.subtract(price_series[lag:], price_series[:-lag])))) for lag in lags]

    # Return the Hurst exponent from linear fit
    try:
        reg = np.polyfit(np.log(lags), np.log(tau), 1)
        return reg[0]  # Hurst exponent is the slope
    except (ValueError, RuntimeWarning):
        # Return 0.5 (random walk) if calculation fails
        return 0.5</file><file path="src/agents/valuation.py">from langchain_core.messages import HumanMessage
from graph.state import AgentState, show_agent_reasoning
from utils.progress import progress
import json

from tools.api import get_financial_metrics, get_market_cap, search_line_items


##### Valuation Agent #####
def valuation_agent(state: AgentState):
    &quot;&quot;&quot;Performs detailed valuation analysis using multiple methodologies for multiple tickers.&quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    # Initialize valuation analysis for each ticker
    valuation_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Fetching financial data&quot;)

        # Fetch the financial metrics
        financial_metrics = get_financial_metrics(
            ticker=ticker,
            end_date=end_date,
            period=&quot;ttm&quot;,
        )

        # Add safety check for financial metrics
        if not financial_metrics:
            progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Failed: No financial metrics found&quot;)
            continue
        
        metrics = financial_metrics[0]

        progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Gathering line items&quot;)
        # Fetch the specific line_items that we need for valuation purposes
        financial_line_items = search_line_items(
            ticker=ticker,
            line_items=[
                &quot;free_cash_flow&quot;,
                &quot;net_income&quot;,
                &quot;depreciation_and_amortization&quot;,
                &quot;capital_expenditure&quot;,
                &quot;working_capital&quot;,
            ],
            end_date=end_date,
            period=&quot;ttm&quot;,
            limit=2,
        )

        # Add safety check for financial line items
        if len(financial_line_items) &lt; 2:
            progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Failed: Insufficient financial line items&quot;)
            continue

        # Pull the current and previous financial line items
        current_financial_line_item = financial_line_items[0]
        previous_financial_line_item = financial_line_items[1]

        progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Calculating owner earnings&quot;)
        # Calculate working capital change
        working_capital_change = current_financial_line_item.working_capital - previous_financial_line_item.working_capital

        # Owner Earnings Valuation (Buffett Method)
        owner_earnings_value = calculate_owner_earnings_value(
            net_income=current_financial_line_item.net_income,
            depreciation=current_financial_line_item.depreciation_and_amortization,
            capex=current_financial_line_item.capital_expenditure,
            working_capital_change=working_capital_change,
            growth_rate=metrics.earnings_growth,
            required_return=0.15,
            margin_of_safety=0.25,
        )

        progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Calculating DCF value&quot;)
        # DCF Valuation
        dcf_value = calculate_intrinsic_value(
            free_cash_flow=current_financial_line_item.free_cash_flow,
            growth_rate=metrics.earnings_growth,
            discount_rate=0.10,
            terminal_growth_rate=0.03,
            num_years=5,
        )

        progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Comparing to market value&quot;)
        # Get the market cap
        market_cap = get_market_cap(ticker=ticker, end_date=end_date)

        # Calculate combined valuation gap (average of both methods)
        dcf_gap = (dcf_value - market_cap) / market_cap
        owner_earnings_gap = (owner_earnings_value - market_cap) / market_cap
        valuation_gap = (dcf_gap + owner_earnings_gap) / 2

        if valuation_gap &gt; 0.15:  # More than 15% undervalued
            signal = &quot;bullish&quot;
        elif valuation_gap &lt; -0.15:  # More than 15% overvalued
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;

        # Create the reasoning
        reasoning = {}
        reasoning[&quot;dcf_analysis&quot;] = {
            &quot;signal&quot;: (&quot;bullish&quot; if dcf_gap &gt; 0.15 else &quot;bearish&quot; if dcf_gap &lt; -0.15 else &quot;neutral&quot;),
            &quot;details&quot;: f&quot;Intrinsic Value: ${dcf_value:,.2f}, Market Cap: ${market_cap:,.2f}, Gap: {dcf_gap:.1%}&quot;,
        }

        reasoning[&quot;owner_earnings_analysis&quot;] = {
            &quot;signal&quot;: (&quot;bullish&quot; if owner_earnings_gap &gt; 0.15 else &quot;bearish&quot; if owner_earnings_gap &lt; -0.15 else &quot;neutral&quot;),
            &quot;details&quot;: f&quot;Owner Earnings Value: ${owner_earnings_value:,.2f}, Market Cap: ${market_cap:,.2f}, Gap: {owner_earnings_gap:.1%}&quot;,
        }

        confidence = round(abs(valuation_gap), 2) * 100
        valuation_analysis[ticker] = {
            &quot;signal&quot;: signal,
            &quot;confidence&quot;: confidence,
            &quot;reasoning&quot;: reasoning,
        }

        progress.update_status(&quot;valuation_agent&quot;, ticker, &quot;Done&quot;)

    message = HumanMessage(
        content=json.dumps(valuation_analysis),
        name=&quot;valuation_agent&quot;,
    )

    # Print the reasoning if the flag is set
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(valuation_analysis, &quot;Valuation Analysis Agent&quot;)

    # Add the signal to the analyst_signals list
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;valuation_agent&quot;] = valuation_analysis

    return {
        &quot;messages&quot;: [message],
        &quot;data&quot;: data,
    }


def calculate_owner_earnings_value(
    net_income: float,
    depreciation: float,
    capex: float,
    working_capital_change: float,
    growth_rate: float = 0.05,
    required_return: float = 0.15,
    margin_of_safety: float = 0.25,
    num_years: int = 5,
) -&gt; float:
    &quot;&quot;&quot;
    Calculates the intrinsic value using Buffett&apos;s Owner Earnings method.

    Owner Earnings = Net Income
                    + Depreciation/Amortization
                    - Capital Expenditures
                    - Working Capital Changes

    Args:
        net_income: Annual net income
        depreciation: Annual depreciation and amortization
        capex: Annual capital expenditures
        working_capital_change: Annual change in working capital
        growth_rate: Expected growth rate
        required_return: Required rate of return (Buffett typically uses 15%)
        margin_of_safety: Margin of safety to apply to final value
        num_years: Number of years to project

    Returns:
        float: Intrinsic value with margin of safety
    &quot;&quot;&quot;
    if not all([isinstance(x, (int, float)) for x in [net_income, depreciation, capex, working_capital_change]]):
        return 0

    # Calculate initial owner earnings
    owner_earnings = net_income + depreciation - capex - working_capital_change

    if owner_earnings &lt;= 0:
        return 0

    # Project future owner earnings
    future_values = []
    for year in range(1, num_years + 1):
        future_value = owner_earnings * (1 + growth_rate) ** year
        discounted_value = future_value / (1 + required_return) ** year
        future_values.append(discounted_value)

    # Calculate terminal value (using perpetuity growth formula)
    terminal_growth = min(growth_rate, 0.03)  # Cap terminal growth at 3%
    terminal_value = (future_values[-1] * (1 + terminal_growth)) / (required_return - terminal_growth)
    terminal_value_discounted = terminal_value / (1 + required_return) ** num_years

    # Sum all values and apply margin of safety
    intrinsic_value = sum(future_values) + terminal_value_discounted
    value_with_safety_margin = intrinsic_value * (1 - margin_of_safety)

    return value_with_safety_margin


def calculate_intrinsic_value(
    free_cash_flow: float,
    growth_rate: float = 0.05,
    discount_rate: float = 0.10,
    terminal_growth_rate: float = 0.02,
    num_years: int = 5,
) -&gt; float:
    &quot;&quot;&quot;
    Computes the discounted cash flow (DCF) for a given company based on the current free cash flow.
    Use this function to calculate the intrinsic value of a stock.
    &quot;&quot;&quot;
    # Estimate the future cash flows based on the growth rate
    cash_flows = [free_cash_flow * (1 + growth_rate) ** i for i in range(num_years)]

    # Calculate the present value of projected cash flows
    present_values = []
    for i in range(num_years):
        present_value = cash_flows[i] / (1 + discount_rate) ** (i + 1)
        present_values.append(present_value)

    # Calculate the terminal value
    terminal_value = cash_flows[-1] * (1 + terminal_growth_rate) / (discount_rate - terminal_growth_rate)
    terminal_present_value = terminal_value / (1 + discount_rate) ** num_years

    # Sum up the present values and terminal value
    dcf_value = sum(present_values) + terminal_present_value

    return dcf_value


def calculate_working_capital_change(
    current_working_capital: float,
    previous_working_capital: float,
) -&gt; float:
    &quot;&quot;&quot;
    Calculate the absolute change in working capital between two periods.
    A positive change means more capital is tied up in working capital (cash outflow).
    A negative change means less capital is tied up (cash inflow).

    Args:
        current_working_capital: Current period&apos;s working capital
        previous_working_capital: Previous period&apos;s working capital

    Returns:
        float: Change in working capital (current - previous)
    &quot;&quot;&quot;
    return current_working_capital - previous_working_capital</file><file path="src/agents/warren_buffett.py">from graph.state import AgentState, show_agent_reasoning
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
import json
from typing_extensions import Literal
from tools.api import get_financial_metrics, get_market_cap, search_line_items
from utils.llm import call_llm
from utils.progress import progress


class WarrenBuffettSignal(BaseModel):
    signal: Literal[&quot;bullish&quot;, &quot;bearish&quot;, &quot;neutral&quot;]
    confidence: float
    reasoning: str


def warren_buffett_agent(state: AgentState):
    &quot;&quot;&quot;Analyzes stocks using Buffett&apos;s principles and LLM reasoning.&quot;&quot;&quot;
    data = state[&quot;data&quot;]
    end_date = data[&quot;end_date&quot;]
    tickers = data[&quot;tickers&quot;]

    # Collect all analysis for LLM reasoning
    analysis_data = {}
    buffett_analysis = {}

    for ticker in tickers:
        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Fetching financial metrics&quot;)
        # Fetch required data
        metrics = get_financial_metrics(ticker, end_date, period=&quot;ttm&quot;, limit=5)

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Gathering financial line items&quot;)
        financial_line_items = search_line_items(
            ticker,
            [
                &quot;capital_expenditure&quot;,
                &quot;depreciation_and_amortization&quot;,
                &quot;net_income&quot;,
                &quot;outstanding_shares&quot;,
                &quot;total_assets&quot;,
                &quot;total_liabilities&quot;,
                &quot;dividends_and_other_cash_distributions&quot;,
                &quot;issuance_or_purchase_of_equity_shares&quot;,
            ],
            end_date,
        )

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Getting market cap&quot;)
        # Get current market cap
        market_cap = get_market_cap(ticker, end_date)

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Analyzing fundamentals&quot;)
        # Analyze fundamentals
        fundamental_analysis = analyze_fundamentals(metrics)

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Analyzing consistency&quot;)
        consistency_analysis = analyze_consistency(financial_line_items)

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Analyzing moat&quot;)
        moat_analysis = analyze_moat(metrics)

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Analyzing management quality&quot;)
        mgmt_analysis = analyze_management_quality(financial_line_items)

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Calculating intrinsic value&quot;)
        intrinsic_value_analysis = calculate_intrinsic_value(financial_line_items)

        # Calculate total score
        total_score = fundamental_analysis[&quot;score&quot;] + consistency_analysis[&quot;score&quot;] + moat_analysis[&quot;score&quot;] + mgmt_analysis[&quot;score&quot;]
        max_possible_score = 10 + moat_analysis[&quot;max_score&quot;] + mgmt_analysis[&quot;max_score&quot;]
        # fundamental_analysis + consistency combined were up to 10 points total
        # moat can add up to 3, mgmt can add up to 2, for example

        # Add margin of safety analysis if we have both intrinsic value and current price
        margin_of_safety = None
        intrinsic_value = intrinsic_value_analysis[&quot;intrinsic_value&quot;]
        if intrinsic_value and market_cap:
            margin_of_safety = (intrinsic_value - market_cap) / market_cap

        # Generate trading signal using a stricter margin-of-safety requirement
        # if fundamentals+moat+management are strong but margin_of_safety &lt; 0.3, itâ€™s neutral
        # if fundamentals are very weak or margin_of_safety is severely negative -&gt; bearish
        # else bullish
        if (total_score &gt;= 0.7 * max_possible_score) and margin_of_safety and (margin_of_safety &gt;= 0.3):
            signal = &quot;bullish&quot;
        elif total_score &lt;= 0.3 * max_possible_score or (margin_of_safety is not None and margin_of_safety &lt; -0.3):
            # negative margin of safety beyond -30% could be overpriced -&gt; bearish
            signal = &quot;bearish&quot;
        else:
            signal = &quot;neutral&quot;

        # Combine all analysis results
        analysis_data[ticker] = {
            &quot;signal&quot;: signal,
            &quot;score&quot;: total_score,
            &quot;max_score&quot;: max_possible_score,
            &quot;fundamental_analysis&quot;: fundamental_analysis,
            &quot;consistency_analysis&quot;: consistency_analysis,
            &quot;moat_analysis&quot;: moat_analysis,
            &quot;management_analysis&quot;: mgmt_analysis,
            &quot;intrinsic_value_analysis&quot;: intrinsic_value_analysis,
            &quot;market_cap&quot;: market_cap,
            &quot;margin_of_safety&quot;: margin_of_safety,
        }

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Generating Buffett analysis&quot;)
        buffett_output = generate_buffett_output(
            ticker=ticker,
            analysis_data=analysis_data,
            model_name=state[&quot;metadata&quot;][&quot;model_name&quot;],
            model_provider=state[&quot;metadata&quot;][&quot;model_provider&quot;],
        )

        # Store analysis in consistent format with other agents
        buffett_analysis[ticker] = {
            &quot;signal&quot;: buffett_output.signal,
            &quot;confidence&quot;: buffett_output.confidence, # Normalize between 0 to 100
            &quot;reasoning&quot;: buffett_output.reasoning,
        }

        progress.update_status(&quot;warren_buffett_agent&quot;, ticker, &quot;Done&quot;)

    # Create the message
    message = HumanMessage(content=json.dumps(buffett_analysis), name=&quot;warren_buffett_agent&quot;)

    # Show reasoning if requested
    if state[&quot;metadata&quot;][&quot;show_reasoning&quot;]:
        show_agent_reasoning(buffett_analysis, &quot;Warren Buffett Agent&quot;)

    # Add the signal to the analyst_signals list
    state[&quot;data&quot;][&quot;analyst_signals&quot;][&quot;warren_buffett_agent&quot;] = buffett_analysis

    return {&quot;messages&quot;: [message], &quot;data&quot;: state[&quot;data&quot;]}


def analyze_fundamentals(metrics: list) -&gt; dict[str, any]:
    &quot;&quot;&quot;Analyze company fundamentals based on Buffett&apos;s criteria.&quot;&quot;&quot;
    if not metrics:
        return {&quot;score&quot;: 0, &quot;details&quot;: &quot;Insufficient fundamental data&quot;}

    latest_metrics = metrics[0]

    score = 0
    reasoning = []

    # Check ROE (Return on Equity)
    if latest_metrics.return_on_equity and latest_metrics.return_on_equity &gt; 0.15:  # 15% ROE threshold
        score += 2
        reasoning.append(f&quot;Strong ROE of {latest_metrics.return_on_equity:.1%}&quot;)
    elif latest_metrics.return_on_equity:
        reasoning.append(f&quot;Weak ROE of {latest_metrics.return_on_equity:.1%}&quot;)
    else:
        reasoning.append(&quot;ROE data not available&quot;)

    # Check Debt to Equity
    if latest_metrics.debt_to_equity and latest_metrics.debt_to_equity &lt; 0.5:
        score += 2
        reasoning.append(&quot;Conservative debt levels&quot;)
    elif latest_metrics.debt_to_equity:
        reasoning.append(f&quot;High debt to equity ratio of {latest_metrics.debt_to_equity:.1f}&quot;)
    else:
        reasoning.append(&quot;Debt to equity data not available&quot;)

    # Check Operating Margin
    if latest_metrics.operating_margin and latest_metrics.operating_margin &gt; 0.15:
        score += 2
        reasoning.append(&quot;Strong operating margins&quot;)
    elif latest_metrics.operating_margin:
        reasoning.append(f&quot;Weak operating margin of {latest_metrics.operating_margin:.1%}&quot;)
    else:
        reasoning.append(&quot;Operating margin data not available&quot;)

    # Check Current Ratio
    if latest_metrics.current_ratio and latest_metrics.current_ratio &gt; 1.5:
        score += 1
        reasoning.append(&quot;Good liquidity position&quot;)
    elif latest_metrics.current_ratio:
        reasoning.append(f&quot;Weak liquidity with current ratio of {latest_metrics.current_ratio:.1f}&quot;)
    else:
        reasoning.append(&quot;Current ratio data not available&quot;)

    return {&quot;score&quot;: score, &quot;details&quot;: &quot;; &quot;.join(reasoning), &quot;metrics&quot;: latest_metrics.model_dump()}


def analyze_consistency(financial_line_items: list) -&gt; dict[str, any]:
    &quot;&quot;&quot;Analyze earnings consistency and growth.&quot;&quot;&quot;
    if len(financial_line_items) &lt; 4:  # Need at least 4 periods for trend analysis
        return {&quot;score&quot;: 0, &quot;details&quot;: &quot;Insufficient historical data&quot;}

    score = 0
    reasoning = []

    # Check earnings growth trend
    earnings_values = [item.net_income for item in financial_line_items if item.net_income]
    if len(earnings_values) &gt;= 4:
        # Simple check: is each period&apos;s earnings bigger than the next?
        earnings_growth = all(earnings_values[i] &gt; earnings_values[i + 1] for i in range(len(earnings_values) - 1))

        if earnings_growth:
            score += 3
            reasoning.append(&quot;Consistent earnings growth over past periods&quot;)
        else:
            reasoning.append(&quot;Inconsistent earnings growth pattern&quot;)

        # Calculate total growth rate from oldest to latest
        if len(earnings_values) &gt;= 2 and earnings_values[-1] != 0:
            growth_rate = (earnings_values[0] - earnings_values[-1]) / abs(earnings_values[-1])
            reasoning.append(f&quot;Total earnings growth of {growth_rate:.1%} over past {len(earnings_values)} periods&quot;)
    else:
        reasoning.append(&quot;Insufficient earnings data for trend analysis&quot;)

    return {
        &quot;score&quot;: score,
        &quot;details&quot;: &quot;; &quot;.join(reasoning),
    }


def analyze_moat(metrics: list) -&gt; dict[str, any]:
    &quot;&quot;&quot;
    Evaluate whether the company likely has a durable competitive advantage (moat).
    For simplicity, we look at stability of ROE/operating margins over multiple periods
    or high margin over the last few years. Higher stability =&gt; higher moat score.
    &quot;&quot;&quot;
    if not metrics or len(metrics) &lt; 3:
        return {&quot;score&quot;: 0, &quot;max_score&quot;: 3, &quot;details&quot;: &quot;Insufficient data for moat analysis&quot;}

    reasoning = []
    moat_score = 0
    historical_roes = []
    historical_margins = []

    for m in metrics:
        if m.return_on_equity is not None:
            historical_roes.append(m.return_on_equity)
        if m.operating_margin is not None:
            historical_margins.append(m.operating_margin)

    # Check for stable or improving ROE
    if len(historical_roes) &gt;= 3:
        stable_roe = all(r &gt; 0.15 for r in historical_roes)
        if stable_roe:
            moat_score += 1
            reasoning.append(&quot;Stable ROE above 15% across periods (suggests moat)&quot;)
        else:
            reasoning.append(&quot;ROE not consistently above 15%&quot;)

    # Check for stable or improving operating margin
    if len(historical_margins) &gt;= 3:
        stable_margin = all(m &gt; 0.15 for m in historical_margins)
        if stable_margin:
            moat_score += 1
            reasoning.append(&quot;Stable operating margins above 15% (moat indicator)&quot;)
        else:
            reasoning.append(&quot;Operating margin not consistently above 15%&quot;)

    # If both are stable/improving, add an extra point
    if moat_score == 2:
        moat_score += 1
        reasoning.append(&quot;Both ROE and margin stability indicate a solid moat&quot;)

    return {
        &quot;score&quot;: moat_score,
        &quot;max_score&quot;: 3,
        &quot;details&quot;: &quot;; &quot;.join(reasoning),
    }


def analyze_management_quality(financial_line_items: list) -&gt; dict[str, any]:
    &quot;&quot;&quot;
    Checks for share dilution or consistent buybacks, and some dividend track record.
    A simplified approach:
      - if there&apos;s net share repurchase or stable share count, it suggests management
        might be shareholder-friendly.
      - if there&apos;s a big new issuance, it might be a negative sign (dilution).
    &quot;&quot;&quot;
    if not financial_line_items:
        return {&quot;score&quot;: 0, &quot;max_score&quot;: 2, &quot;details&quot;: &quot;Insufficient data for management analysis&quot;}

    reasoning = []
    mgmt_score = 0

    latest = financial_line_items[0]
    if hasattr(latest, &quot;issuance_or_purchase_of_equity_shares&quot;) and latest.issuance_or_purchase_of_equity_shares and latest.issuance_or_purchase_of_equity_shares &lt; 0:
        # Negative means the company spent money on buybacks
        mgmt_score += 1
        reasoning.append(&quot;Company has been repurchasing shares (shareholder-friendly)&quot;)

    if hasattr(latest, &quot;issuance_or_purchase_of_equity_shares&quot;) and latest.issuance_or_purchase_of_equity_shares and latest.issuance_or_purchase_of_equity_shares &gt; 0:
        # Positive issuance means new shares =&gt; possible dilution
        reasoning.append(&quot;Recent common stock issuance (potential dilution)&quot;)
    else:
        reasoning.append(&quot;No significant new stock issuance detected&quot;)

    # Check for any dividends
    if hasattr(latest, &quot;dividends_and_other_cash_distributions&quot;) and latest.dividends_and_other_cash_distributions and latest.dividends_and_other_cash_distributions &lt; 0:
        mgmt_score += 1
        reasoning.append(&quot;Company has a track record of paying dividends&quot;)
    else:
        reasoning.append(&quot;No or minimal dividends paid&quot;)

    return {
        &quot;score&quot;: mgmt_score,
        &quot;max_score&quot;: 2,
        &quot;details&quot;: &quot;; &quot;.join(reasoning),
    }


def calculate_owner_earnings(financial_line_items: list) -&gt; dict[str, any]:
    &quot;&quot;&quot;Calculate owner earnings (Buffett&apos;s preferred measure of true earnings power).
    Owner Earnings = Net Income + Depreciation - Maintenance CapEx&quot;&quot;&quot;
    if not financial_line_items or len(financial_line_items) &lt; 1:
        return {&quot;owner_earnings&quot;: None, &quot;details&quot;: [&quot;Insufficient data for owner earnings calculation&quot;]}

    latest = financial_line_items[0]

    net_income = latest.net_income
    depreciation = latest.depreciation_and_amortization
    capex = latest.capital_expenditure

    if not all([net_income, depreciation, capex]):
        return {&quot;owner_earnings&quot;: None, &quot;details&quot;: [&quot;Missing components for owner earnings calculation&quot;]}

    # Estimate maintenance capex (typically 70-80% of total capex)
    maintenance_capex = capex * 0.75
    owner_earnings = net_income + depreciation - maintenance_capex

    return {
        &quot;owner_earnings&quot;: owner_earnings,
        &quot;components&quot;: {&quot;net_income&quot;: net_income, &quot;depreciation&quot;: depreciation, &quot;maintenance_capex&quot;: maintenance_capex},
        &quot;details&quot;: [&quot;Owner earnings calculated successfully&quot;],
    }


def calculate_intrinsic_value(financial_line_items: list) -&gt; dict[str, any]:
    &quot;&quot;&quot;Calculate intrinsic value using DCF with owner earnings.&quot;&quot;&quot;
    if not financial_line_items:
        return {&quot;intrinsic_value&quot;: None, &quot;details&quot;: [&quot;Insufficient data for valuation&quot;]}

    # Calculate owner earnings
    earnings_data = calculate_owner_earnings(financial_line_items)
    if not earnings_data[&quot;owner_earnings&quot;]:
        return {&quot;intrinsic_value&quot;: None, &quot;details&quot;: earnings_data[&quot;details&quot;]}

    owner_earnings = earnings_data[&quot;owner_earnings&quot;]

    # Get current market data
    latest_financial_line_items = financial_line_items[0]
    shares_outstanding = latest_financial_line_items.outstanding_shares

    if not shares_outstanding:
        return {&quot;intrinsic_value&quot;: None, &quot;details&quot;: [&quot;Missing shares outstanding data&quot;]}

    # Buffett&apos;s DCF assumptions (conservative approach)
    growth_rate = 0.05  # Conservative 5% growth
    discount_rate = 0.09  # Typical ~9% discount rate
    terminal_multiple = 12
    projection_years = 10

    # Sum of discounted future owner earnings
    future_value = 0
    for year in range(1, projection_years + 1):
        future_earnings = owner_earnings * (1 + growth_rate) ** year
        present_value = future_earnings / (1 + discount_rate) ** year
        future_value += present_value

    # Terminal value
    terminal_value = (owner_earnings * (1 + growth_rate) ** projection_years * terminal_multiple) / ((1 + discount_rate) ** projection_years)

    intrinsic_value = future_value + terminal_value

    return {
        &quot;intrinsic_value&quot;: intrinsic_value,
        &quot;owner_earnings&quot;: owner_earnings,
        &quot;assumptions&quot;: {
            &quot;growth_rate&quot;: growth_rate,
            &quot;discount_rate&quot;: discount_rate,
            &quot;terminal_multiple&quot;: terminal_multiple,
            &quot;projection_years&quot;: projection_years,
        },
        &quot;details&quot;: [&quot;Intrinsic value calculated using DCF model with owner earnings&quot;],
    }


def generate_buffett_output(
    ticker: str,
    analysis_data: dict[str, any],
    model_name: str,
    model_provider: str,
) -&gt; WarrenBuffettSignal:
    &quot;&quot;&quot;Get investment decision from LLM with Buffett&apos;s principles&quot;&quot;&quot;
    template = ChatPromptTemplate.from_messages(
        [
            (
                &quot;system&quot;,
                &quot;&quot;&quot;You are a Warren Buffett AI agent. Decide on investment signals based on Warren Buffettâ€™s principles:
                - Circle of Competence: Only invest in businesses you understand
                - Margin of Safety (&gt; 30%): Buy at a significant discount to intrinsic value
                - Economic Moat: Look for durable competitive advantages
                - Quality Management: Seek conservative, shareholder-oriented teams
                - Financial Strength: Favor low debt, strong returns on equity
                - Long-term Horizon: Invest in businesses, not just stocks
                - Sell only if fundamentals deteriorate or valuation far exceeds intrinsic value

                Follow these guidelines strictly.
                &quot;&quot;&quot;,
            ),
            (
                &quot;human&quot;,
                &quot;&quot;&quot;Based on the following data, create the investment signal as Warren Buffett would:

                Analysis Data for {ticker}:
                {analysis_data}

                Return the trading signal in the following JSON format exactly:
                {{
                  &quot;signal&quot;: &quot;bullish&quot; | &quot;bearish&quot; | &quot;neutral&quot;,
                  &quot;confidence&quot;: float between 0 and 100,
                  &quot;reasoning&quot;: &quot;string&quot;
                }}
                &quot;&quot;&quot;,
            ),
        ]
    )

    prompt = template.invoke({&quot;analysis_data&quot;: json.dumps(analysis_data, indent=2), &quot;ticker&quot;: ticker})

    # Default fallback signal in case parsing fails
    def create_default_warren_buffett_signal():
        return WarrenBuffettSignal(signal=&quot;neutral&quot;, confidence=0.0, reasoning=&quot;Error in analysis, defaulting to neutral&quot;)

    return call_llm(
        prompt=prompt,
        model_name=model_name,
        model_provider=model_provider,
        pydantic_model=WarrenBuffettSignal,
        agent_name=&quot;warren_buffett_agent&quot;,
        default_factory=create_default_warren_buffett_signal,
    )</file><file path="src/data/cache.py">class Cache:
    &quot;&quot;&quot;In-memory cache for API responses.&quot;&quot;&quot;

    def __init__(self):
        self._prices_cache: dict[str, list[dict[str, any]]] = {}
        self._financial_metrics_cache: dict[str, list[dict[str, any]]] = {}
        self._line_items_cache: dict[str, list[dict[str, any]]] = {}
        self._insider_trades_cache: dict[str, list[dict[str, any]]] = {}
        self._company_news_cache: dict[str, list[dict[str, any]]] = {}

    def _merge_data(self, existing: list[dict] | None, new_data: list[dict], key_field: str) -&gt; list[dict]:
        &quot;&quot;&quot;Merge existing and new data, avoiding duplicates based on a key field.&quot;&quot;&quot;
        if not existing:
            return new_data
        
        # Create a set of existing keys for O(1) lookup
        existing_keys = {item[key_field] for item in existing}
        
        # Only add items that don&apos;t exist yet
        merged = existing.copy()
        merged.extend([item for item in new_data if item[key_field] not in existing_keys])
        return merged

    def get_prices(self, ticker: str) -&gt; list[dict[str, any]] | None:
        &quot;&quot;&quot;Get cached price data if available.&quot;&quot;&quot;
        return self._prices_cache.get(ticker)

    def set_prices(self, ticker: str, data: list[dict[str, any]]):
        &quot;&quot;&quot;Append new price data to cache.&quot;&quot;&quot;
        self._prices_cache[ticker] = self._merge_data(
            self._prices_cache.get(ticker),
            data,
            key_field=&quot;time&quot;
        )

    def get_financial_metrics(self, ticker: str) -&gt; list[dict[str, any]]:
        &quot;&quot;&quot;Get cached financial metrics if available.&quot;&quot;&quot;
        return self._financial_metrics_cache.get(ticker)

    def set_financial_metrics(self, ticker: str, data: list[dict[str, any]]):
        &quot;&quot;&quot;Append new financial metrics to cache.&quot;&quot;&quot;
        self._financial_metrics_cache[ticker] = self._merge_data(
            self._financial_metrics_cache.get(ticker),
            data,
            key_field=&quot;report_period&quot;
        )

    def get_line_items(self, ticker: str) -&gt; list[dict[str, any]] | None:
        &quot;&quot;&quot;Get cached line items if available.&quot;&quot;&quot;
        return self._line_items_cache.get(ticker)

    def set_line_items(self, ticker: str, data: list[dict[str, any]]):
        &quot;&quot;&quot;Append new line items to cache.&quot;&quot;&quot;
        self._line_items_cache[ticker] = self._merge_data(
            self._line_items_cache.get(ticker),
            data,
            key_field=&quot;report_period&quot;
        )

    def get_insider_trades(self, ticker: str) -&gt; list[dict[str, any]] | None:
        &quot;&quot;&quot;Get cached insider trades if available.&quot;&quot;&quot;
        return self._insider_trades_cache.get(ticker)

    def set_insider_trades(self, ticker: str, data: list[dict[str, any]]):
        &quot;&quot;&quot;Append new insider trades to cache.&quot;&quot;&quot;
        self._insider_trades_cache[ticker] = self._merge_data(
            self._insider_trades_cache.get(ticker),
            data,
            key_field=&quot;filing_date&quot;  # Could also use transaction_date if preferred
        )

    def get_company_news(self, ticker: str) -&gt; list[dict[str, any]] | None:
        &quot;&quot;&quot;Get cached company news if available.&quot;&quot;&quot;
        return self._company_news_cache.get(ticker)

    def set_company_news(self, ticker: str, data: list[dict[str, any]]):
        &quot;&quot;&quot;Append new company news to cache.&quot;&quot;&quot;
        self._company_news_cache[ticker] = self._merge_data(
            self._company_news_cache.get(ticker),
            data,
            key_field=&quot;date&quot;
        )


# Global cache instance
_cache = Cache()


def get_cache() -&gt; Cache:
    &quot;&quot;&quot;Get the global cache instance.&quot;&quot;&quot;
    return _cache</file><file path="src/data/models.py">from pydantic import BaseModel


class Price(BaseModel):
    open: float
    close: float
    high: float
    low: float
    volume: int
    time: str


class PriceResponse(BaseModel):
    ticker: str
    prices: list[Price]


class FinancialMetrics(BaseModel):
    ticker: str
    report_period: str
    period: str
    currency: str
    market_cap: float | None
    enterprise_value: float | None
    price_to_earnings_ratio: float | None
    price_to_book_ratio: float | None
    price_to_sales_ratio: float | None
    enterprise_value_to_ebitda_ratio: float | None
    enterprise_value_to_revenue_ratio: float | None
    free_cash_flow_yield: float | None
    peg_ratio: float | None
    gross_margin: float | None
    operating_margin: float | None
    net_margin: float | None
    return_on_equity: float | None
    return_on_assets: float | None
    return_on_invested_capital: float | None
    asset_turnover: float | None
    inventory_turnover: float | None
    receivables_turnover: float | None
    days_sales_outstanding: float | None
    operating_cycle: float | None
    working_capital_turnover: float | None
    current_ratio: float | None
    quick_ratio: float | None
    cash_ratio: float | None
    operating_cash_flow_ratio: float | None
    debt_to_equity: float | None
    debt_to_assets: float | None
    interest_coverage: float | None
    revenue_growth: float | None
    earnings_growth: float | None
    book_value_growth: float | None
    earnings_per_share_growth: float | None
    free_cash_flow_growth: float | None
    operating_income_growth: float | None
    ebitda_growth: float | None
    payout_ratio: float | None
    earnings_per_share: float | None
    book_value_per_share: float | None
    free_cash_flow_per_share: float | None


class FinancialMetricsResponse(BaseModel):
    financial_metrics: list[FinancialMetrics]


class LineItem(BaseModel):
    ticker: str
    report_period: str
    period: str
    currency: str

    # Allow additional fields dynamically
    model_config = {&quot;extra&quot;: &quot;allow&quot;}


class LineItemResponse(BaseModel):
    search_results: list[LineItem]


class InsiderTrade(BaseModel):
    ticker: str
    issuer: str | None
    name: str | None
    title: str | None
    is_board_director: bool | None
    transaction_date: str | None
    transaction_shares: float | None
    transaction_price_per_share: float | None
    transaction_value: float | None
    shares_owned_before_transaction: float | None
    shares_owned_after_transaction: float | None
    security_title: str | None
    filing_date: str


class InsiderTradeResponse(BaseModel):
    insider_trades: list[InsiderTrade]


class CompanyNews(BaseModel):
    ticker: str
    title: str
    author: str
    source: str
    date: str
    url: str
    sentiment: str | None = None


class CompanyNewsResponse(BaseModel):
    news: list[CompanyNews]


class Position(BaseModel):
    cash: float = 0.0
    shares: int = 0
    ticker: str


class Portfolio(BaseModel):
    positions: dict[str, Position]  # ticker -&gt; Position mapping
    total_cash: float = 0.0


class AnalystSignal(BaseModel):
    signal: str | None = None
    confidence: float | None = None
    reasoning: dict | str | None = None
    max_position_size: float | None = None  # For risk management signals


class TickerAnalysis(BaseModel):
    ticker: str
    analyst_signals: dict[str, AnalystSignal]  # agent_name -&gt; signal mapping


class AgentStateData(BaseModel):
    tickers: list[str]
    portfolio: Portfolio
    start_date: str
    end_date: str
    ticker_analyses: dict[str, TickerAnalysis]  # ticker -&gt; analysis mapping


class AgentStateMetadata(BaseModel):
    show_reasoning: bool = False
    model_config = {&quot;extra&quot;: &quot;allow&quot;}</file><file path="src/graph/state.py">from typing_extensions import Annotated, Sequence, TypedDict

import operator
from langchain_core.messages import BaseMessage


import json


def merge_dicts(a: dict[str, any], b: dict[str, any]) -&gt; dict[str, any]:
    return {**a, **b}


# Define agent state
class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], operator.add]
    data: Annotated[dict[str, any], merge_dicts]
    metadata: Annotated[dict[str, any], merge_dicts]


def show_agent_reasoning(output, agent_name):
    print(f&quot;\n{&apos;=&apos; * 10} {agent_name.center(28)} {&apos;=&apos; * 10}&quot;)

    def convert_to_serializable(obj):
        if hasattr(obj, &quot;to_dict&quot;):  # Handle Pandas Series/DataFrame
            return obj.to_dict()
        elif hasattr(obj, &quot;__dict__&quot;):  # Handle custom objects
            return obj.__dict__
        elif isinstance(obj, (int, float, bool, str)):
            return obj
        elif isinstance(obj, (list, tuple)):
            return [convert_to_serializable(item) for item in obj]
        elif isinstance(obj, dict):
            return {key: convert_to_serializable(value) for key, value in obj.items()}
        else:
            return str(obj)  # Fallback to string representation

    if isinstance(output, (dict, list)):
        # Convert the output to JSON-serializable format
        serializable_output = convert_to_serializable(output)
        print(json.dumps(serializable_output, indent=2))
    else:
        try:
            # Parse the string as JSON and pretty print it
            parsed_output = json.loads(output)
            print(json.dumps(parsed_output, indent=2))
        except json.JSONDecodeError:
            # Fallback to original string if not valid JSON
            print(output)

    print(&quot;=&quot; * 48)</file><file path="src/llm/models.py">import os
from langchain_anthropic import ChatAnthropic
from langchain_deepseek import ChatDeepSeek
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_groq import ChatGroq
from langchain_openai import ChatOpenAI
from enum import Enum
from pydantic import BaseModel
from typing import Tuple


class ModelProvider(str, Enum):
    &quot;&quot;&quot;Enum for supported LLM providers&quot;&quot;&quot;
    ANTHROPIC = &quot;Anthropic&quot;
    DEEPSEEK = &quot;DeepSeek&quot;
    GEMINI = &quot;Gemini&quot;
    GROQ = &quot;Groq&quot;
    OPENAI = &quot;OpenAI&quot;



class LLMModel(BaseModel):
    &quot;&quot;&quot;Represents an LLM model configuration&quot;&quot;&quot;
    display_name: str
    model_name: str
    provider: ModelProvider

    def to_choice_tuple(self) -&gt; Tuple[str, str, str]:
        &quot;&quot;&quot;Convert to format needed for questionary choices&quot;&quot;&quot;
        return (self.display_name, self.model_name, self.provider.value)
    
    def has_json_mode(self) -&gt; bool:
        &quot;&quot;&quot;Check if the model supports JSON mode&quot;&quot;&quot;
        return not self.is_deepseek() and not self.is_gemini()
    
    def is_deepseek(self) -&gt; bool:
        &quot;&quot;&quot;Check if the model is a DeepSeek model&quot;&quot;&quot;
        return self.model_name.startswith(&quot;deepseek&quot;)
    
    def is_gemini(self) -&gt; bool:
        &quot;&quot;&quot;Check if the model is a Gemini model&quot;&quot;&quot;
        return self.model_name.startswith(&quot;gemini&quot;)


# Define available models
AVAILABLE_MODELS = [
    LLMModel(
        display_name=&quot;[anthropic] claude-3.5-haiku&quot;,
        model_name=&quot;claude-3-5-haiku-latest&quot;,
        provider=ModelProvider.ANTHROPIC
    ),
    LLMModel(
        display_name=&quot;[anthropic] claude-3.5-sonnet&quot;,
        model_name=&quot;claude-3-5-sonnet-latest&quot;,
        provider=ModelProvider.ANTHROPIC
    ),
    LLMModel(
        display_name=&quot;[anthropic] claude-3.7-sonnet&quot;,
        model_name=&quot;claude-3-7-sonnet-latest&quot;,
        provider=ModelProvider.ANTHROPIC
    ),
    LLMModel(
        display_name=&quot;[deepseek] deepseek-r1&quot;,
        model_name=&quot;deepseek-reasoner&quot;,
        provider=ModelProvider.DEEPSEEK
    ),
    LLMModel(
        display_name=&quot;[deepseek] deepseek-v3&quot;,
        model_name=&quot;deepseek-chat&quot;,
        provider=ModelProvider.DEEPSEEK
    ),
    LLMModel(
        display_name=&quot;[gemini] gemini-2.0-flash&quot;,
        model_name=&quot;gemini-2.0-flash&quot;,
        provider=ModelProvider.GEMINI
    ),
    LLMModel(
        display_name=&quot;[gemini] gemini-2.0-pro&quot;,
        model_name=&quot;gemini-2.0-pro-exp-02-05&quot;,
        provider=ModelProvider.GEMINI
    ),
    LLMModel(
        display_name=&quot;[groq] llama-3.3 70b&quot;,
        model_name=&quot;llama-3.3-70b-versatile&quot;,
        provider=ModelProvider.GROQ
    ),
    LLMModel(
        display_name=&quot;[openai] gpt-4.5&quot;,
        model_name=&quot;gpt-4.5-preview&quot;,
        provider=ModelProvider.OPENAI
    ),
    LLMModel(
        display_name=&quot;[openai] gpt-4o&quot;,
        model_name=&quot;gpt-4o&quot;,
        provider=ModelProvider.OPENAI
    ),
    LLMModel(
        display_name=&quot;[openai] o1&quot;,
        model_name=&quot;o1&quot;,
        provider=ModelProvider.OPENAI
    ),
    LLMModel(
        display_name=&quot;[openai] o3-mini&quot;,
        model_name=&quot;o3-mini&quot;,
        provider=ModelProvider.OPENAI
    ),
]

# Create LLM_ORDER in the format expected by the UI
LLM_ORDER = [model.to_choice_tuple() for model in AVAILABLE_MODELS]

def get_model_info(model_name: str) -&gt; LLMModel | None:
    &quot;&quot;&quot;Get model information by model_name&quot;&quot;&quot;
    return next((model for model in AVAILABLE_MODELS if model.model_name == model_name), None)

def get_model(model_name: str, model_provider: ModelProvider) -&gt; ChatOpenAI | ChatGroq | None:
    if model_provider == ModelProvider.GROQ:
        api_key = os.getenv(&quot;GROQ_API_KEY&quot;)
        if not api_key:
            # Print error to console
            print(f&quot;API Key Error: Please make sure GROQ_API_KEY is set in your .env file.&quot;)
            raise ValueError(&quot;Groq API key not found.  Please make sure GROQ_API_KEY is set in your .env file.&quot;)
        return ChatGroq(model=model_name, api_key=api_key)
    elif model_provider == ModelProvider.OPENAI:
        # Get and validate API key
        api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)
        if not api_key:
            # Print error to console
            print(f&quot;API Key Error: Please make sure OPENAI_API_KEY is set in your .env file.&quot;)
            raise ValueError(&quot;OpenAI API key not found.  Please make sure OPENAI_API_KEY is set in your .env file.&quot;)
        return ChatOpenAI(model=model_name, api_key=api_key)
    elif model_provider == ModelProvider.ANTHROPIC:
        api_key = os.getenv(&quot;ANTHROPIC_API_KEY&quot;)
        if not api_key:
            print(f&quot;API Key Error: Please make sure ANTHROPIC_API_KEY is set in your .env file.&quot;)
            raise ValueError(&quot;Anthropic API key not found.  Please make sure ANTHROPIC_API_KEY is set in your .env file.&quot;)
        return ChatAnthropic(model=model_name, api_key=api_key)
    elif model_provider == ModelProvider.DEEPSEEK:
        api_key = os.getenv(&quot;DEEPSEEK_API_KEY&quot;)
        if not api_key:
            print(f&quot;API Key Error: Please make sure DEEPSEEK_API_KEY is set in your .env file.&quot;)
            raise ValueError(&quot;DeepSeek API key not found.  Please make sure DEEPSEEK_API_KEY is set in your .env file.&quot;)
        return ChatDeepSeek(model=model_name, api_key=api_key)
    elif model_provider == ModelProvider.GEMINI:
        api_key = os.getenv(&quot;GOOGLE_API_KEY&quot;)
        if not api_key:
            print(f&quot;API Key Error: Please make sure GOOGLE_API_KEY is set in your .env file.&quot;)
            raise ValueError(&quot;Google API key not found.  Please make sure GOOGLE_API_KEY is set in your .env file.&quot;)
        return ChatGoogleGenerativeAI(model=model_name, api_key=api_key)</file><file path="src/tools/api.py">import os
import pandas as pd
import requests

from data.cache import get_cache
from data.models import (
    CompanyNews,
    CompanyNewsResponse,
    FinancialMetrics,
    FinancialMetricsResponse,
    Price,
    PriceResponse,
    LineItem,
    LineItemResponse,
    InsiderTrade,
    InsiderTradeResponse,
)

# Global cache instance
_cache = get_cache()


def get_prices(ticker: str, start_date: str, end_date: str) -&gt; list[Price]:
    &quot;&quot;&quot;Fetch price data from cache or API.&quot;&quot;&quot;
    # Check cache first
    if cached_data := _cache.get_prices(ticker):
        # Filter cached data by date range and convert to Price objects
        filtered_data = [Price(**price) for price in cached_data if start_date &lt;= price[&quot;time&quot;] &lt;= end_date]
        if filtered_data:
            return filtered_data

    # If not in cache or no data in range, fetch from API
    headers = {}
    if api_key := os.environ.get(&quot;FINANCIAL_DATASETS_API_KEY&quot;):
        headers[&quot;X-API-KEY&quot;] = api_key

    url = f&quot;https://api.financialdatasets.ai/prices/?ticker={ticker}&amp;interval=day&amp;interval_multiplier=1&amp;start_date={start_date}&amp;end_date={end_date}&quot;
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        raise Exception(f&quot;Error fetching data: {ticker} - {response.status_code} - {response.text}&quot;)

    # Parse response with Pydantic model
    price_response = PriceResponse(**response.json())
    prices = price_response.prices

    if not prices:
        return []

    # Cache the results as dicts
    _cache.set_prices(ticker, [p.model_dump() for p in prices])
    return prices


def get_financial_metrics(
    ticker: str,
    end_date: str,
    period: str = &quot;ttm&quot;,
    limit: int = 10,
) -&gt; list[FinancialMetrics]:
    &quot;&quot;&quot;Fetch financial metrics from cache or API.&quot;&quot;&quot;
    # Check cache first
    if cached_data := _cache.get_financial_metrics(ticker):
        # Filter cached data by date and limit
        filtered_data = [FinancialMetrics(**metric) for metric in cached_data if metric[&quot;report_period&quot;] &lt;= end_date]
        filtered_data.sort(key=lambda x: x.report_period, reverse=True)
        if filtered_data:
            return filtered_data[:limit]

    # If not in cache or insufficient data, fetch from API
    headers = {}
    if api_key := os.environ.get(&quot;FINANCIAL_DATASETS_API_KEY&quot;):
        headers[&quot;X-API-KEY&quot;] = api_key

    url = f&quot;https://api.financialdatasets.ai/financial-metrics/?ticker={ticker}&amp;report_period_lte={end_date}&amp;limit={limit}&amp;period={period}&quot;
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        raise Exception(f&quot;Error fetching data: {ticker} - {response.status_code} - {response.text}&quot;)

    # Parse response with Pydantic model
    metrics_response = FinancialMetricsResponse(**response.json())
    # Return the FinancialMetrics objects directly instead of converting to dict
    financial_metrics = metrics_response.financial_metrics

    if not financial_metrics:
        return []

    # Cache the results as dicts
    _cache.set_financial_metrics(ticker, [m.model_dump() for m in financial_metrics])
    return financial_metrics


def search_line_items(
    ticker: str,
    line_items: list[str],
    end_date: str,
    period: str = &quot;ttm&quot;,
    limit: int = 10,
) -&gt; list[LineItem]:
    &quot;&quot;&quot;Fetch line items from API.&quot;&quot;&quot;
    # If not in cache or insufficient data, fetch from API
    headers = {}
    if api_key := os.environ.get(&quot;FINANCIAL_DATASETS_API_KEY&quot;):
        headers[&quot;X-API-KEY&quot;] = api_key

    url = &quot;https://api.financialdatasets.ai/financials/search/line-items&quot;

    body = {
        &quot;tickers&quot;: [ticker],
        &quot;line_items&quot;: line_items,
        &quot;end_date&quot;: end_date,
        &quot;period&quot;: period,
        &quot;limit&quot;: limit,
    }
    response = requests.post(url, headers=headers, json=body)
    if response.status_code != 200:
        raise Exception(f&quot;Error fetching data: {ticker} - {response.status_code} - {response.text}&quot;)
    data = response.json()
    response_model = LineItemResponse(**data)
    search_results = response_model.search_results
    if not search_results:
        return []

    # Cache the results
    return search_results[:limit]


def get_insider_trades(
    ticker: str,
    end_date: str,
    start_date: str | None = None,
    limit: int = 1000,
) -&gt; list[InsiderTrade]:
    &quot;&quot;&quot;Fetch insider trades from cache or API.&quot;&quot;&quot;
    # Check cache first
    if cached_data := _cache.get_insider_trades(ticker):
        # Filter cached data by date range
        filtered_data = [InsiderTrade(**trade) for trade in cached_data 
                        if (start_date is None or (trade.get(&quot;transaction_date&quot;) or trade[&quot;filing_date&quot;]) &gt;= start_date)
                        and (trade.get(&quot;transaction_date&quot;) or trade[&quot;filing_date&quot;]) &lt;= end_date]
        filtered_data.sort(key=lambda x: x.transaction_date or x.filing_date, reverse=True)
        if filtered_data:
            return filtered_data

    # If not in cache or insufficient data, fetch from API
    headers = {}
    if api_key := os.environ.get(&quot;FINANCIAL_DATASETS_API_KEY&quot;):
        headers[&quot;X-API-KEY&quot;] = api_key

    all_trades = []
    current_end_date = end_date
    
    while True:
        url = f&quot;https://api.financialdatasets.ai/insider-trades/?ticker={ticker}&amp;filing_date_lte={current_end_date}&quot;
        if start_date:
            url += f&quot;&amp;filing_date_gte={start_date}&quot;
        url += f&quot;&amp;limit={limit}&quot;
        
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            raise Exception(f&quot;Error fetching data: {ticker} - {response.status_code} - {response.text}&quot;)
        
        data = response.json()
        response_model = InsiderTradeResponse(**data)
        insider_trades = response_model.insider_trades
        
        if not insider_trades:
            break
            
        all_trades.extend(insider_trades)
        
        # Only continue pagination if we have a start_date and got a full page
        if not start_date or len(insider_trades) &lt; limit:
            break
            
        # Update end_date to the oldest filing date from current batch for next iteration
        current_end_date = min(trade.filing_date for trade in insider_trades).split(&apos;T&apos;)[0]
        
        # If we&apos;ve reached or passed the start_date, we can stop
        if current_end_date &lt;= start_date:
            break

    if not all_trades:
        return []

    # Cache the results
    _cache.set_insider_trades(ticker, [trade.model_dump() for trade in all_trades])
    return all_trades


def get_company_news(
    ticker: str,
    end_date: str,
    start_date: str | None = None,
    limit: int = 1000,
) -&gt; list[CompanyNews]:
    &quot;&quot;&quot;Fetch company news from cache or API.&quot;&quot;&quot;
    # Check cache first
    if cached_data := _cache.get_company_news(ticker):
        # Filter cached data by date range
        filtered_data = [CompanyNews(**news) for news in cached_data 
                        if (start_date is None or news[&quot;date&quot;] &gt;= start_date)
                        and news[&quot;date&quot;] &lt;= end_date]
        filtered_data.sort(key=lambda x: x.date, reverse=True)
        if filtered_data:
            return filtered_data

    # If not in cache or insufficient data, fetch from API
    headers = {}
    if api_key := os.environ.get(&quot;FINANCIAL_DATASETS_API_KEY&quot;):
        headers[&quot;X-API-KEY&quot;] = api_key

    all_news = []
    current_end_date = end_date
    
    while True:
        url = f&quot;https://api.financialdatasets.ai/news/?ticker={ticker}&amp;end_date={current_end_date}&quot;
        if start_date:
            url += f&quot;&amp;start_date={start_date}&quot;
        url += f&quot;&amp;limit={limit}&quot;
        
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            raise Exception(f&quot;Error fetching data: {ticker} - {response.status_code} - {response.text}&quot;)
        
        data = response.json()
        response_model = CompanyNewsResponse(**data)
        company_news = response_model.news
        
        if not company_news:
            break
            
        all_news.extend(company_news)
        
        # Only continue pagination if we have a start_date and got a full page
        if not start_date or len(company_news) &lt; limit:
            break
            
        # Update end_date to the oldest date from current batch for next iteration
        current_end_date = min(news.date for news in company_news).split(&apos;T&apos;)[0]
        
        # If we&apos;ve reached or passed the start_date, we can stop
        if current_end_date &lt;= start_date:
            break

    if not all_news:
        return []

    # Cache the results
    _cache.set_company_news(ticker, [news.model_dump() for news in all_news])
    return all_news



def get_market_cap(
    ticker: str,
    end_date: str,
) -&gt; float | None:
    &quot;&quot;&quot;Fetch market cap from the API.&quot;&quot;&quot;
    financial_metrics = get_financial_metrics(ticker, end_date)
    market_cap = financial_metrics[0].market_cap
    if not market_cap:
        return None

    return market_cap


def prices_to_df(prices: list[Price]) -&gt; pd.DataFrame:
    &quot;&quot;&quot;Convert prices to a DataFrame.&quot;&quot;&quot;
    df = pd.DataFrame([p.model_dump() for p in prices])
    df[&quot;Date&quot;] = pd.to_datetime(df[&quot;time&quot;])
    df.set_index(&quot;Date&quot;, inplace=True)
    numeric_cols = [&quot;open&quot;, &quot;close&quot;, &quot;high&quot;, &quot;low&quot;, &quot;volume&quot;]
    for col in numeric_cols:
        df[col] = pd.to_numeric(df[col], errors=&quot;coerce&quot;)
    df.sort_index(inplace=True)
    return df


# Update the get_price_data function to use the new functions
def get_price_data(ticker: str, start_date: str, end_date: str) -&gt; pd.DataFrame:
    prices = get_prices(ticker, start_date, end_date)
    return prices_to_df(prices)</file><file path="src/utils/__init__.py"># This file can be empty</file><file path="src/utils/analysts.py">&quot;&quot;&quot;Constants and utilities related to analysts configuration.&quot;&quot;&quot;

from agents.ben_graham import ben_graham_agent
from agents.bill_ackman import bill_ackman_agent
from agents.cathie_wood import cathie_wood_agent
from agents.charlie_munger import charlie_munger_agent
from agents.fundamentals import fundamentals_agent
from agents.sentiment import sentiment_agent
from agents.stanley_druckenmiller import stanley_druckenmiller_agent
from agents.technicals import technical_analyst_agent
from agents.valuation import valuation_agent
from agents.warren_buffett import warren_buffett_agent

# Define analyst configuration - single source of truth
ANALYST_CONFIG = {
    &quot;ben_graham&quot;: {
        &quot;display_name&quot;: &quot;Ben Graham&quot;,
        &quot;agent_func&quot;: ben_graham_agent,
        &quot;order&quot;: 0,
    },
    &quot;bill_ackman&quot;: {
        &quot;display_name&quot;: &quot;Bill Ackman&quot;,
        &quot;agent_func&quot;: bill_ackman_agent,
        &quot;order&quot;: 1,
    },
    &quot;cathie_wood&quot;: {
        &quot;display_name&quot;: &quot;Cathie Wood&quot;,
        &quot;agent_func&quot;: cathie_wood_agent,
        &quot;order&quot;: 2,
    },
    &quot;charlie_munger&quot;: {
        &quot;display_name&quot;: &quot;Charlie Munger&quot;,
        &quot;agent_func&quot;: charlie_munger_agent,
        &quot;order&quot;: 3,
    },
    &quot;stanley_druckenmiller&quot;: {
        &quot;display_name&quot;: &quot;Stanley Druckenmiller&quot;,
        &quot;agent_func&quot;: stanley_druckenmiller_agent,
        &quot;order&quot;: 4,
    },
    &quot;warren_buffett&quot;: {
        &quot;display_name&quot;: &quot;Warren Buffett&quot;,
        &quot;agent_func&quot;: warren_buffett_agent,
        &quot;order&quot;: 5,
    },
    &quot;technical_analyst&quot;: {
        &quot;display_name&quot;: &quot;Technical Analyst&quot;,
        &quot;agent_func&quot;: technical_analyst_agent,
        &quot;order&quot;: 6,
    },
    &quot;fundamentals_analyst&quot;: {
        &quot;display_name&quot;: &quot;Fundamentals Analyst&quot;,
        &quot;agent_func&quot;: fundamentals_agent,
        &quot;order&quot;: 7,
    },
    &quot;sentiment_analyst&quot;: {
        &quot;display_name&quot;: &quot;Sentiment Analyst&quot;,
        &quot;agent_func&quot;: sentiment_agent,
        &quot;order&quot;: 8,
    },
    &quot;valuation_analyst&quot;: {
        &quot;display_name&quot;: &quot;Valuation Analyst&quot;,
        &quot;agent_func&quot;: valuation_agent,
        &quot;order&quot;: 9,
    },
}

# Derive ANALYST_ORDER from ANALYST_CONFIG for backwards compatibility
ANALYST_ORDER = [(config[&quot;display_name&quot;], key) for key, config in sorted(ANALYST_CONFIG.items(), key=lambda x: x[1][&quot;order&quot;])]


def get_analyst_nodes():
    &quot;&quot;&quot;Get the mapping of analyst keys to their (node_name, agent_func) tuples.&quot;&quot;&quot;
    return {key: (f&quot;{key}_agent&quot;, config[&quot;agent_func&quot;]) for key, config in ANALYST_CONFIG.items()}</file><file path="src/utils/display.py">from colorama import Fore, Style
from tabulate import tabulate
from .analysts import ANALYST_ORDER
import os


def sort_analyst_signals(signals):
    &quot;&quot;&quot;Sort analyst signals in a consistent order.&quot;&quot;&quot;
    # Create order mapping from ANALYST_ORDER
    analyst_order = {display: idx for idx, (display, _) in enumerate(ANALYST_ORDER)}
    analyst_order[&quot;Risk Management&quot;] = len(ANALYST_ORDER)  # Add Risk Management at the end

    return sorted(signals, key=lambda x: analyst_order.get(x[0], 999))


def print_trading_output(result: dict) -&gt; None:
    &quot;&quot;&quot;
    Print formatted trading results with colored tables for multiple tickers.

    Args:
        result (dict): Dictionary containing decisions and analyst signals for multiple tickers
    &quot;&quot;&quot;
    decisions = result.get(&quot;decisions&quot;)
    if not decisions:
        print(f&quot;{Fore.RED}No trading decisions available{Style.RESET_ALL}&quot;)
        return

    # Print decisions for each ticker
    for ticker, decision in decisions.items():
        print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}Analysis for {Fore.CYAN}{ticker}{Style.RESET_ALL}&quot;)
        print(f&quot;{Fore.WHITE}{Style.BRIGHT}{&apos;=&apos; * 50}{Style.RESET_ALL}&quot;)

        # Prepare analyst signals table for this ticker
        table_data = []
        for agent, signals in result.get(&quot;analyst_signals&quot;, {}).items():
            if ticker not in signals:
                continue

            signal = signals[ticker]
            agent_name = agent.replace(&quot;_agent&quot;, &quot;&quot;).replace(&quot;_&quot;, &quot; &quot;).title()
            signal_type = signal.get(&quot;signal&quot;, &quot;&quot;).upper()

            signal_color = {
                &quot;BULLISH&quot;: Fore.GREEN,
                &quot;BEARISH&quot;: Fore.RED,
                &quot;NEUTRAL&quot;: Fore.YELLOW,
            }.get(signal_type, Fore.WHITE)

            table_data.append(
                [
                    f&quot;{Fore.CYAN}{agent_name}{Style.RESET_ALL}&quot;,
                    f&quot;{signal_color}{signal_type}{Style.RESET_ALL}&quot;,
                    f&quot;{Fore.YELLOW}{signal.get(&apos;confidence&apos;)}%{Style.RESET_ALL}&quot;,
                ]
            )

        # Sort the signals according to the predefined order
        table_data = sort_analyst_signals(table_data)

        print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}ANALYST SIGNALS:{Style.RESET_ALL} [{Fore.CYAN}{ticker}{Style.RESET_ALL}]&quot;)
        print(
            tabulate(
                table_data,
                headers=[f&quot;{Fore.WHITE}Analyst&quot;, &quot;Signal&quot;, &quot;Confidence&quot;],
                tablefmt=&quot;grid&quot;,
                colalign=(&quot;left&quot;, &quot;center&quot;, &quot;right&quot;),
            )
        )

        # Print Trading Decision Table
        action = decision.get(&quot;action&quot;, &quot;&quot;).upper()
        action_color = {&quot;BUY&quot;: Fore.GREEN, &quot;SELL&quot;: Fore.RED, &quot;HOLD&quot;: Fore.YELLOW}.get(action, Fore.WHITE)

        decision_data = [
            [&quot;Action&quot;, f&quot;{action_color}{action}{Style.RESET_ALL}&quot;],
            [&quot;Quantity&quot;, f&quot;{action_color}{decision.get(&apos;quantity&apos;)}{Style.RESET_ALL}&quot;],
            [
                &quot;Confidence&quot;,
                f&quot;{Fore.YELLOW}{decision.get(&apos;confidence&apos;):.1f}%{Style.RESET_ALL}&quot;,
            ],
        ]

        print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}TRADING DECISION:{Style.RESET_ALL} [{Fore.CYAN}{ticker}{Style.RESET_ALL}]&quot;)
        print(tabulate(decision_data, tablefmt=&quot;grid&quot;, colalign=(&quot;left&quot;, &quot;right&quot;)))

        # Print Reasoning
        print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}Reasoning:{Style.RESET_ALL} {Fore.CYAN}{decision.get(&apos;reasoning&apos;)}{Style.RESET_ALL}&quot;)

    # Print Portfolio Summary
    print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}PORTFOLIO SUMMARY:{Style.RESET_ALL}&quot;)
    portfolio_data = []
    for ticker, decision in decisions.items():
        action = decision.get(&quot;action&quot;, &quot;&quot;).upper()
        action_color = {
            &quot;BUY&quot;: Fore.GREEN,
            &quot;SELL&quot;: Fore.RED,
            &quot;HOLD&quot;: Fore.YELLOW,
            &quot;COVER&quot;: Fore.GREEN,
            &quot;SHORT&quot;: Fore.RED,
        }.get(action, Fore.WHITE)
        portfolio_data.append(
            [
                f&quot;{Fore.CYAN}{ticker}{Style.RESET_ALL}&quot;,
                f&quot;{action_color}{action}{Style.RESET_ALL}&quot;,
                f&quot;{action_color}{decision.get(&apos;quantity&apos;)}{Style.RESET_ALL}&quot;,
                f&quot;{Fore.YELLOW}{decision.get(&apos;confidence&apos;):.1f}%{Style.RESET_ALL}&quot;,
            ]
        )

    print(
        tabulate(
            portfolio_data,
            headers=[f&quot;{Fore.WHITE}Ticker&quot;, &quot;Action&quot;, &quot;Quantity&quot;, &quot;Confidence&quot;],
            tablefmt=&quot;grid&quot;,
            colalign=(&quot;left&quot;, &quot;center&quot;, &quot;right&quot;, &quot;right&quot;),
        )
    )


def print_backtest_results(table_rows: list) -&gt; None:
    &quot;&quot;&quot;Print the backtest results in a nicely formatted table&quot;&quot;&quot;
    # Clear the screen
    os.system(&quot;cls&quot; if os.name == &quot;nt&quot; else &quot;clear&quot;)

    # Split rows into ticker rows and summary rows
    ticker_rows = []
    summary_rows = []

    for row in table_rows:
        if isinstance(row[1], str) and &quot;PORTFOLIO SUMMARY&quot; in row[1]:
            summary_rows.append(row)
        else:
            ticker_rows.append(row)

    
    # Display latest portfolio summary
    if summary_rows:
        latest_summary = summary_rows[-1]
        print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}PORTFOLIO SUMMARY:{Style.RESET_ALL}&quot;)

        # Extract values and remove commas before converting to float
        cash_str = latest_summary[7].split(&quot;$&quot;)[1].split(Style.RESET_ALL)[0].replace(&quot;,&quot;, &quot;&quot;)
        position_str = latest_summary[6].split(&quot;$&quot;)[1].split(Style.RESET_ALL)[0].replace(&quot;,&quot;, &quot;&quot;)
        total_str = latest_summary[8].split(&quot;$&quot;)[1].split(Style.RESET_ALL)[0].replace(&quot;,&quot;, &quot;&quot;)

        print(f&quot;Cash Balance: {Fore.CYAN}${float(cash_str):,.2f}{Style.RESET_ALL}&quot;)
        print(f&quot;Total Position Value: {Fore.YELLOW}${float(position_str):,.2f}{Style.RESET_ALL}&quot;)
        print(f&quot;Total Value: {Fore.WHITE}${float(total_str):,.2f}{Style.RESET_ALL}&quot;)
        print(f&quot;Return: {latest_summary[9]}&quot;)
        
        # Display performance metrics if available
        if latest_summary[10]:  # Sharpe ratio
            print(f&quot;Sharpe Ratio: {latest_summary[10]}&quot;)
        if latest_summary[11]:  # Sortino ratio
            print(f&quot;Sortino Ratio: {latest_summary[11]}&quot;)
        if latest_summary[12]:  # Max drawdown
            print(f&quot;Max Drawdown: {latest_summary[12]}&quot;)

    # Add vertical spacing
    print(&quot;\n&quot; * 2)

    # Print the table with just ticker rows
    print(
        tabulate(
            ticker_rows,
            headers=[
                &quot;Date&quot;,
                &quot;Ticker&quot;,
                &quot;Action&quot;,
                &quot;Quantity&quot;,
                &quot;Price&quot;,
                &quot;Shares&quot;,
                &quot;Position Value&quot;,
                &quot;Bullish&quot;,
                &quot;Bearish&quot;,
                &quot;Neutral&quot;,
            ],
            tablefmt=&quot;grid&quot;,
            colalign=(
                &quot;left&quot;,  # Date
                &quot;left&quot;,  # Ticker
                &quot;center&quot;,  # Action
                &quot;right&quot;,  # Quantity
                &quot;right&quot;,  # Price
                &quot;right&quot;,  # Shares
                &quot;right&quot;,  # Position Value
                &quot;right&quot;,  # Bullish
                &quot;right&quot;,  # Bearish
                &quot;right&quot;,  # Neutral
            ),
        )
    )

    # Add vertical spacing
    print(&quot;\n&quot; * 4)


def format_backtest_row(
    date: str,
    ticker: str,
    action: str,
    quantity: float,
    price: float,
    shares_owned: float,
    position_value: float,
    bullish_count: int,
    bearish_count: int,
    neutral_count: int,
    is_summary: bool = False,
    total_value: float = None,
    return_pct: float = None,
    cash_balance: float = None,
    total_position_value: float = None,
    sharpe_ratio: float = None,
    sortino_ratio: float = None,
    max_drawdown: float = None,
) -&gt; list[any]:
    &quot;&quot;&quot;Format a row for the backtest results table&quot;&quot;&quot;
    # Color the action
    action_color = {
        &quot;BUY&quot;: Fore.GREEN,
        &quot;COVER&quot;: Fore.GREEN,
        &quot;SELL&quot;: Fore.RED,
        &quot;SHORT&quot;: Fore.RED,
        &quot;HOLD&quot;: Fore.YELLOW,
    }.get(action.upper(), Fore.WHITE)

    if is_summary:
        return_color = Fore.GREEN if return_pct &gt;= 0 else Fore.RED
        return [
            date,
            f&quot;{Fore.WHITE}{Style.BRIGHT}PORTFOLIO SUMMARY{Style.RESET_ALL}&quot;,
            &quot;&quot;,  # Action
            &quot;&quot;,  # Quantity
            &quot;&quot;,  # Price
            &quot;&quot;,  # Shares
            f&quot;{Fore.YELLOW}${total_position_value:,.2f}{Style.RESET_ALL}&quot;,  # Total Position Value
            f&quot;{Fore.CYAN}${cash_balance:,.2f}{Style.RESET_ALL}&quot;,  # Cash Balance
            f&quot;{Fore.WHITE}${total_value:,.2f}{Style.RESET_ALL}&quot;,  # Total Value
            f&quot;{return_color}{return_pct:+.2f}%{Style.RESET_ALL}&quot;,  # Return
            f&quot;{Fore.YELLOW}{sharpe_ratio:.2f}{Style.RESET_ALL}&quot; if sharpe_ratio is not None else &quot;&quot;,  # Sharpe Ratio
            f&quot;{Fore.YELLOW}{sortino_ratio:.2f}{Style.RESET_ALL}&quot; if sortino_ratio is not None else &quot;&quot;,  # Sortino Ratio
            f&quot;{Fore.RED}{max_drawdown:.2f}%{Style.RESET_ALL}&quot; if max_drawdown is not None else &quot;&quot;,  # Max Drawdown
        ]
    else:
        return [
            date,
            f&quot;{Fore.CYAN}{ticker}{Style.RESET_ALL}&quot;,
            f&quot;{action_color}{action.upper()}{Style.RESET_ALL}&quot;,
            f&quot;{action_color}{quantity:,.0f}{Style.RESET_ALL}&quot;,
            f&quot;{Fore.WHITE}{price:,.2f}{Style.RESET_ALL}&quot;,
            f&quot;{Fore.WHITE}{shares_owned:,.0f}{Style.RESET_ALL}&quot;,
            f&quot;{Fore.YELLOW}{position_value:,.2f}{Style.RESET_ALL}&quot;,
            f&quot;{Fore.GREEN}{bullish_count}{Style.RESET_ALL}&quot;,
            f&quot;{Fore.RED}{bearish_count}{Style.RESET_ALL}&quot;,
            f&quot;{Fore.BLUE}{neutral_count}{Style.RESET_ALL}&quot;,
        ]</file><file path="src/utils/llm.py">&quot;&quot;&quot;Helper functions for LLM&quot;&quot;&quot;

import json
from typing import TypeVar, Type, Optional, Any
from pydantic import BaseModel
from utils.progress import progress

T = TypeVar(&apos;T&apos;, bound=BaseModel)

def call_llm(
    prompt: Any,
    model_name: str,
    model_provider: str,
    pydantic_model: Type[T],
    agent_name: Optional[str] = None,
    max_retries: int = 3,
    default_factory = None
) -&gt; T:
    &quot;&quot;&quot;
    Makes an LLM call with retry logic, handling both Deepseek and non-Deepseek models.
    
    Args:
        prompt: The prompt to send to the LLM
        model_name: Name of the model to use
        model_provider: Provider of the model
        pydantic_model: The Pydantic model class to structure the output
        agent_name: Optional name of the agent for progress updates
        max_retries: Maximum number of retries (default: 3)
        default_factory: Optional factory function to create default response on failure
        
    Returns:
        An instance of the specified Pydantic model
    &quot;&quot;&quot;
    from llm.models import get_model, get_model_info
    
    model_info = get_model_info(model_name)
    llm = get_model(model_name, model_provider)
    
    # For non-JSON support models, we can use structured output
    if not (model_info and not model_info.has_json_mode()):
        llm = llm.with_structured_output(
            pydantic_model,
            method=&quot;json_mode&quot;,
        )
    
    # Call the LLM with retries
    for attempt in range(max_retries):
        try:
            # Call the LLM
            result = llm.invoke(prompt)
            
            # For non-JSON support models, we need to extract and parse the JSON manually
            if model_info and not model_info.has_json_mode():
                parsed_result = extract_json_from_deepseek_response(result.content)
                if parsed_result:
                    return pydantic_model(**parsed_result)
            else:
                return result
                
        except Exception as e:
            if agent_name:
                progress.update_status(agent_name, None, f&quot;Error - retry {attempt + 1}/{max_retries}&quot;)
            
            if attempt == max_retries - 1:
                print(f&quot;Error in LLM call after {max_retries} attempts: {e}&quot;)
                # Use default_factory if provided, otherwise create a basic default
                if default_factory:
                    return default_factory()
                return create_default_response(pydantic_model)

    # This should never be reached due to the retry logic above
    return create_default_response(pydantic_model)

def create_default_response(model_class: Type[T]) -&gt; T:
    &quot;&quot;&quot;Creates a safe default response based on the model&apos;s fields.&quot;&quot;&quot;
    default_values = {}
    for field_name, field in model_class.model_fields.items():
        if field.annotation == str:
            default_values[field_name] = &quot;Error in analysis, using default&quot;
        elif field.annotation == float:
            default_values[field_name] = 0.0
        elif field.annotation == int:
            default_values[field_name] = 0
        elif hasattr(field.annotation, &quot;__origin__&quot;) and field.annotation.__origin__ == dict:
            default_values[field_name] = {}
        else:
            # For other types (like Literal), try to use the first allowed value
            if hasattr(field.annotation, &quot;__args__&quot;):
                default_values[field_name] = field.annotation.__args__[0]
            else:
                default_values[field_name] = None
    
    return model_class(**default_values)

def extract_json_from_deepseek_response(content: str) -&gt; Optional[dict]:
    &quot;&quot;&quot;Extracts JSON from Deepseek&apos;s markdown-formatted response.&quot;&quot;&quot;
    try:
        json_start = content.find(&quot;```json&quot;)
        if json_start != -1:
            json_text = content[json_start + 7:]  # Skip past ```json
            json_end = json_text.find(&quot;```&quot;)
            if json_end != -1:
                json_text = json_text[:json_end].strip()
                return json.loads(json_text)
    except Exception as e:
        print(f&quot;Error extracting JSON from Deepseek response: {e}&quot;)
    return None</file><file path="src/utils/progress.py">from rich.console import Console
from rich.live import Live
from rich.table import Table
from rich.style import Style
from rich.text import Text
from typing import Dict, Optional
from datetime import datetime

console = Console()


class AgentProgress:
    &quot;&quot;&quot;Manages progress tracking for multiple agents.&quot;&quot;&quot;

    def __init__(self):
        self.agent_status: Dict[str, Dict[str, str]] = {}
        self.table = Table(show_header=False, box=None, padding=(0, 1))
        self.live = Live(self.table, console=console, refresh_per_second=4)
        self.started = False

    def start(self):
        &quot;&quot;&quot;Start the progress display.&quot;&quot;&quot;
        if not self.started:
            self.live.start()
            self.started = True

    def stop(self):
        &quot;&quot;&quot;Stop the progress display.&quot;&quot;&quot;
        if self.started:
            self.live.stop()
            self.started = False

    def update_status(self, agent_name: str, ticker: Optional[str] = None, status: str = &quot;&quot;):
        &quot;&quot;&quot;Update the status of an agent.&quot;&quot;&quot;
        if agent_name not in self.agent_status:
            self.agent_status[agent_name] = {&quot;status&quot;: &quot;&quot;, &quot;ticker&quot;: None}

        if ticker:
            self.agent_status[agent_name][&quot;ticker&quot;] = ticker
        if status:
            self.agent_status[agent_name][&quot;status&quot;] = status

        self._refresh_display()

    def _refresh_display(self):
        &quot;&quot;&quot;Refresh the progress display.&quot;&quot;&quot;
        self.table.columns.clear()
        self.table.add_column(width=100)

        # Sort agents with Risk Management and Portfolio Management at the bottom
        def sort_key(item):
            agent_name = item[0]
            if &quot;risk_management&quot; in agent_name:
                return (2, agent_name)
            elif &quot;portfolio_management&quot; in agent_name:
                return (3, agent_name)
            else:
                return (1, agent_name)

        for agent_name, info in sorted(self.agent_status.items(), key=sort_key):
            status = info[&quot;status&quot;]
            ticker = info[&quot;ticker&quot;]

            # Create the status text with appropriate styling
            if status.lower() == &quot;done&quot;:
                style = Style(color=&quot;green&quot;, bold=True)
                symbol = &quot;âœ“&quot;
            elif status.lower() == &quot;error&quot;:
                style = Style(color=&quot;red&quot;, bold=True)
                symbol = &quot;âœ—&quot;
            else:
                style = Style(color=&quot;yellow&quot;)
                symbol = &quot;â‹¯&quot;

            agent_display = agent_name.replace(&quot;_agent&quot;, &quot;&quot;).replace(&quot;_&quot;, &quot; &quot;).title()
            status_text = Text()
            status_text.append(f&quot;{symbol} &quot;, style=style)
            status_text.append(f&quot;{agent_display:&lt;20}&quot;, style=Style(bold=True))

            if ticker:
                status_text.append(f&quot;[{ticker}] &quot;, style=Style(color=&quot;cyan&quot;))
            status_text.append(status, style=style)

            self.table.add_row(status_text)


# Create a global instance
progress = AgentProgress()</file><file path="src/utils/visualize.py">from langgraph.graph.state import CompiledGraph
from langchain_core.runnables.graph import MermaidDrawMethod


def save_graph_as_png(app: CompiledGraph, output_file_path) -&gt; None:
    png_image = app.get_graph().draw_mermaid_png(draw_method=MermaidDrawMethod.API)
    file_path = output_file_path if len(output_file_path) &gt; 0 else &quot;graph.png&quot;
    with open(file_path, &quot;wb&quot;) as f:
        f.write(png_image)</file><file path="src/backtester.py">import sys

from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
import questionary

import matplotlib.pyplot as plt
import pandas as pd
from colorama import Fore, Style, init
import numpy as np
import itertools

from llm.models import LLM_ORDER, get_model_info
from utils.analysts import ANALYST_ORDER
from main import run_hedge_fund
from tools.api import (
    get_company_news,
    get_price_data,
    get_prices,
    get_financial_metrics,
    get_insider_trades,
)
from utils.display import print_backtest_results, format_backtest_row
from typing_extensions import Callable

init(autoreset=True)


class Backtester:
    def __init__(
        self,
        agent: Callable,
        tickers: list[str],
        start_date: str,
        end_date: str,
        initial_capital: float,
        model_name: str = &quot;gpt-4o&quot;,
        model_provider: str = &quot;OpenAI&quot;,
        selected_analysts: list[str] = [],
        initial_margin_requirement: float = 0.0,
    ):
        &quot;&quot;&quot;
        :param agent: The trading agent (Callable).
        :param tickers: List of tickers to backtest.
        :param start_date: Start date string (YYYY-MM-DD).
        :param end_date: End date string (YYYY-MM-DD).
        :param initial_capital: Starting portfolio cash.
        :param model_name: Which LLM model name to use (gpt-4, etc).
        :param model_provider: Which LLM provider (OpenAI, etc).
        :param selected_analysts: List of analyst names or IDs to incorporate.
        :param initial_margin_requirement: The margin ratio (e.g. 0.5 = 50%).
        &quot;&quot;&quot;
        self.agent = agent
        self.tickers = tickers
        self.start_date = start_date
        self.end_date = end_date
        self.initial_capital = initial_capital
        self.model_name = model_name
        self.model_provider = model_provider
        self.selected_analysts = selected_analysts

        # Store the margin ratio (e.g. 0.5 means 50% margin required).
        self.margin_ratio = initial_margin_requirement

        # Initialize portfolio with support for long/short positions
        self.portfolio_values = []
        self.portfolio = {
            &quot;cash&quot;: initial_capital,
            &quot;margin_used&quot;: 0.0,  # total margin usage across all short positions
            &quot;positions&quot;: {
                ticker: {
                    &quot;long&quot;: 0,               # Number of shares held long
                    &quot;short&quot;: 0,              # Number of shares held short
                    &quot;long_cost_basis&quot;: 0.0,  # Average cost basis per share (long)
                    &quot;short_cost_basis&quot;: 0.0, # Average cost basis per share (short)
                    &quot;short_margin_used&quot;: 0.0 # Dollars of margin used for this ticker&apos;s short
                } for ticker in tickers
            },
            &quot;realized_gains&quot;: {
                ticker: {
                    &quot;long&quot;: 0.0,   # Realized gains from long positions
                    &quot;short&quot;: 0.0,  # Realized gains from short positions
                } for ticker in tickers
            }
        }

    def execute_trade(self, ticker: str, action: str, quantity: float, current_price: float):
        &quot;&quot;&quot;
        Execute trades with support for both long and short positions.
        `quantity` is the number of shares the agent wants to buy/sell/short/cover.
        We will only trade integer shares to keep it simple.
        &quot;&quot;&quot;
        if quantity &lt;= 0:
            return 0

        quantity = int(quantity)  # force integer shares
        position = self.portfolio[&quot;positions&quot;][ticker]

        if action == &quot;buy&quot;:
            cost = quantity * current_price
            if cost &lt;= self.portfolio[&quot;cash&quot;]:
                # Weighted average cost basis for the new total
                old_shares = position[&quot;long&quot;]
                old_cost_basis = position[&quot;long_cost_basis&quot;]
                new_shares = quantity
                total_shares = old_shares + new_shares

                if total_shares &gt; 0:
                    total_old_cost = old_cost_basis * old_shares
                    total_new_cost = cost
                    position[&quot;long_cost_basis&quot;] = (total_old_cost + total_new_cost) / total_shares

                position[&quot;long&quot;] += quantity
                self.portfolio[&quot;cash&quot;] -= cost
                return quantity
            else:
                # Calculate maximum affordable quantity
                max_quantity = int(self.portfolio[&quot;cash&quot;] / current_price)
                if max_quantity &gt; 0:
                    cost = max_quantity * current_price
                    old_shares = position[&quot;long&quot;]
                    old_cost_basis = position[&quot;long_cost_basis&quot;]
                    total_shares = old_shares + max_quantity

                    if total_shares &gt; 0:
                        total_old_cost = old_cost_basis * old_shares
                        total_new_cost = cost
                        position[&quot;long_cost_basis&quot;] = (total_old_cost + total_new_cost) / total_shares

                    position[&quot;long&quot;] += max_quantity
                    self.portfolio[&quot;cash&quot;] -= cost
                    return max_quantity
                return 0

        elif action == &quot;sell&quot;:
            # You can only sell as many as you own
            quantity = min(quantity, position[&quot;long&quot;])
            if quantity &gt; 0:
                # Realized gain/loss using average cost basis
                avg_cost_per_share = position[&quot;long_cost_basis&quot;] if position[&quot;long&quot;] &gt; 0 else 0
                realized_gain = (current_price - avg_cost_per_share) * quantity
                self.portfolio[&quot;realized_gains&quot;][ticker][&quot;long&quot;] += realized_gain

                position[&quot;long&quot;] -= quantity
                self.portfolio[&quot;cash&quot;] += quantity * current_price

                if position[&quot;long&quot;] == 0:
                    position[&quot;long_cost_basis&quot;] = 0.0

                return quantity

        elif action == &quot;short&quot;:
            &quot;&quot;&quot;
            Typical short sale flow:
              1) Receive proceeds = current_price * quantity
              2) Post margin_required = proceeds * margin_ratio
              3) Net effect on cash = +proceeds - margin_required
            &quot;&quot;&quot;
            proceeds = current_price * quantity
            margin_required = proceeds * self.margin_ratio
            if margin_required &lt;= self.portfolio[&quot;cash&quot;]:
                # Weighted average short cost basis
                old_short_shares = position[&quot;short&quot;]
                old_cost_basis = position[&quot;short_cost_basis&quot;]
                new_shares = quantity
                total_shares = old_short_shares + new_shares

                if total_shares &gt; 0:
                    total_old_cost = old_cost_basis * old_short_shares
                    total_new_cost = current_price * new_shares
                    position[&quot;short_cost_basis&quot;] = (total_old_cost + total_new_cost) / total_shares

                position[&quot;short&quot;] += quantity

                # Update margin usage
                position[&quot;short_margin_used&quot;] += margin_required
                self.portfolio[&quot;margin_used&quot;] += margin_required

                # Increase cash by proceeds, then subtract the required margin
                self.portfolio[&quot;cash&quot;] += proceeds
                self.portfolio[&quot;cash&quot;] -= margin_required
                return quantity
            else:
                # Calculate maximum shortable quantity
                if self.margin_ratio &gt; 0:
                    max_quantity = int(self.portfolio[&quot;cash&quot;] / (current_price * self.margin_ratio))
                else:
                    max_quantity = 0

                if max_quantity &gt; 0:
                    proceeds = current_price * max_quantity
                    margin_required = proceeds * self.margin_ratio

                    old_short_shares = position[&quot;short&quot;]
                    old_cost_basis = position[&quot;short_cost_basis&quot;]
                    total_shares = old_short_shares + max_quantity

                    if total_shares &gt; 0:
                        total_old_cost = old_cost_basis * old_short_shares
                        total_new_cost = current_price * max_quantity
                        position[&quot;short_cost_basis&quot;] = (total_old_cost + total_new_cost) / total_shares

                    position[&quot;short&quot;] += max_quantity
                    position[&quot;short_margin_used&quot;] += margin_required
                    self.portfolio[&quot;margin_used&quot;] += margin_required

                    self.portfolio[&quot;cash&quot;] += proceeds
                    self.portfolio[&quot;cash&quot;] -= margin_required
                    return max_quantity
                return 0

        elif action == &quot;cover&quot;:
            &quot;&quot;&quot;
            When covering shares:
              1) Pay cover cost = current_price * quantity
              2) Release a proportional share of the margin
              3) Net effect on cash = -cover_cost + released_margin
            &quot;&quot;&quot;
            quantity = min(quantity, position[&quot;short&quot;])
            if quantity &gt; 0:
                cover_cost = quantity * current_price
                avg_short_price = position[&quot;short_cost_basis&quot;] if position[&quot;short&quot;] &gt; 0 else 0
                realized_gain = (avg_short_price - current_price) * quantity

                if position[&quot;short&quot;] &gt; 0:
                    portion = quantity / position[&quot;short&quot;]
                else:
                    portion = 1.0

                margin_to_release = portion * position[&quot;short_margin_used&quot;]

                position[&quot;short&quot;] -= quantity
                position[&quot;short_margin_used&quot;] -= margin_to_release
                self.portfolio[&quot;margin_used&quot;] -= margin_to_release

                # Pay the cost to cover, but get back the released margin
                self.portfolio[&quot;cash&quot;] += margin_to_release
                self.portfolio[&quot;cash&quot;] -= cover_cost

                self.portfolio[&quot;realized_gains&quot;][ticker][&quot;short&quot;] += realized_gain

                if position[&quot;short&quot;] == 0:
                    position[&quot;short_cost_basis&quot;] = 0.0
                    position[&quot;short_margin_used&quot;] = 0.0

                return quantity

        return 0

    def calculate_portfolio_value(self, current_prices):
        &quot;&quot;&quot;
        Calculate total portfolio value, including:
          - cash
          - market value of long positions
          - unrealized gains/losses for short positions
        &quot;&quot;&quot;
        total_value = self.portfolio[&quot;cash&quot;]

        for ticker in self.tickers:
            position = self.portfolio[&quot;positions&quot;][ticker]
            price = current_prices[ticker]

            # Long position value
            long_value = position[&quot;long&quot;] * price
            total_value += long_value

            # Short position unrealized PnL = short_shares * (short_cost_basis - current_price)
            if position[&quot;short&quot;] &gt; 0:
                total_value += position[&quot;short&quot;] * (position[&quot;short_cost_basis&quot;] - price)

        return total_value

    def prefetch_data(self):
        &quot;&quot;&quot;Pre-fetch all data needed for the backtest period.&quot;&quot;&quot;
        print(&quot;\nPre-fetching data for the entire backtest period...&quot;)

        # Convert end_date string to datetime, fetch up to 1 year before
        end_date_dt = datetime.strptime(self.end_date, &quot;%Y-%m-%d&quot;)
        start_date_dt = end_date_dt - relativedelta(years=1)
        start_date_str = start_date_dt.strftime(&quot;%Y-%m-%d&quot;)

        for ticker in self.tickers:
            # Fetch price data for the entire period, plus 1 year
            get_prices(ticker, start_date_str, self.end_date)

            # Fetch financial metrics
            get_financial_metrics(ticker, self.end_date, limit=10)

            # Fetch insider trades
            get_insider_trades(ticker, self.end_date, start_date=self.start_date, limit=1000)

            # Fetch company news
            get_company_news(ticker, self.end_date, start_date=self.start_date, limit=1000)

        print(&quot;Data pre-fetch complete.&quot;)

    def parse_agent_response(self, agent_output):
        &quot;&quot;&quot;Parse JSON output from the agent (fallback to &apos;hold&apos; if invalid).&quot;&quot;&quot;
        import json

        try:
            decision = json.loads(agent_output)
            return decision
        except Exception:
            print(f&quot;Error parsing action: {agent_output}&quot;)
            return {&quot;action&quot;: &quot;hold&quot;, &quot;quantity&quot;: 0}

    def run_backtest(self):
        # Pre-fetch all data at the start
        self.prefetch_data()

        dates = pd.date_range(self.start_date, self.end_date, freq=&quot;B&quot;)
        table_rows = []
        performance_metrics = {
            &apos;sharpe_ratio&apos;: None,
            &apos;sortino_ratio&apos;: None,
            &apos;max_drawdown&apos;: None,
            &apos;long_short_ratio&apos;: None,
            &apos;gross_exposure&apos;: None,
            &apos;net_exposure&apos;: None
        }

        print(&quot;\nStarting backtest...&quot;)

        # Initialize portfolio values list with initial capital
        if len(dates) &gt; 0:
            self.portfolio_values = [{&quot;Date&quot;: dates[0], &quot;Portfolio Value&quot;: self.initial_capital}]
        else:
            self.portfolio_values = []

        for current_date in dates:
            lookback_start = (current_date - timedelta(days=30)).strftime(&quot;%Y-%m-%d&quot;)
            current_date_str = current_date.strftime(&quot;%Y-%m-%d&quot;)
            previous_date_str = (current_date - timedelta(days=1)).strftime(&quot;%Y-%m-%d&quot;)

            # Skip if there&apos;s no prior day to look back (i.e., first date in the range)
            if lookback_start == current_date_str:
                continue

            # Get current prices for all tickers
            try:
                current_prices = {
                    ticker: get_price_data(ticker, previous_date_str, current_date_str).iloc[-1][&quot;close&quot;]
                    for ticker in self.tickers
                }
            except Exception:
                # If data is missing or there&apos;s an API error, skip this day
                print(f&quot;Error fetching prices between {previous_date_str} and {current_date_str}&quot;)
                continue

            # ---------------------------------------------------------------
            # 1) Execute the agent&apos;s trades
            # ---------------------------------------------------------------
            output = self.agent(
                tickers=self.tickers,
                start_date=lookback_start,
                end_date=current_date_str,
                portfolio=self.portfolio,
                model_name=self.model_name,
                model_provider=self.model_provider,
                selected_analysts=self.selected_analysts,
            )
            decisions = output[&quot;decisions&quot;]
            analyst_signals = output[&quot;analyst_signals&quot;]

            # Execute trades for each ticker
            executed_trades = {}
            for ticker in self.tickers:
                decision = decisions.get(ticker, {&quot;action&quot;: &quot;hold&quot;, &quot;quantity&quot;: 0})
                action, quantity = decision.get(&quot;action&quot;, &quot;hold&quot;), decision.get(&quot;quantity&quot;, 0)

                executed_quantity = self.execute_trade(ticker, action, quantity, current_prices[ticker])
                executed_trades[ticker] = executed_quantity

            # ---------------------------------------------------------------
            # 2) Now that trades have executed trades, recalculate the final
            #    portfolio value for this day.
            # ---------------------------------------------------------------
            total_value = self.calculate_portfolio_value(current_prices)

            # Also compute long/short exposures for final postâ€trade state
            long_exposure = sum(
                self.portfolio[&quot;positions&quot;][t][&quot;long&quot;] * current_prices[t]
                for t in self.tickers
            )
            short_exposure = sum(
                self.portfolio[&quot;positions&quot;][t][&quot;short&quot;] * current_prices[t]
                for t in self.tickers
            )

            # Calculate gross and net exposures
            gross_exposure = long_exposure + short_exposure
            net_exposure = long_exposure - short_exposure
            long_short_ratio = (
                long_exposure / short_exposure if short_exposure &gt; 1e-9 else float(&apos;inf&apos;)
            )

            # Track each day&apos;s portfolio value in self.portfolio_values
            self.portfolio_values.append({
                &quot;Date&quot;: current_date,
                &quot;Portfolio Value&quot;: total_value,
                &quot;Long Exposure&quot;: long_exposure,
                &quot;Short Exposure&quot;: short_exposure,
                &quot;Gross Exposure&quot;: gross_exposure,
                &quot;Net Exposure&quot;: net_exposure,
                &quot;Long/Short Ratio&quot;: long_short_ratio
            })

            # ---------------------------------------------------------------
            # 3) Build the table rows to display
            # ---------------------------------------------------------------
            date_rows = []

            # For each ticker, record signals/trades
            for ticker in self.tickers:
                ticker_signals = {}
                for agent_name, signals in analyst_signals.items():
                    if ticker in signals:
                        ticker_signals[agent_name] = signals[ticker]

                bullish_count = len([s for s in ticker_signals.values() if s.get(&quot;signal&quot;, &quot;&quot;).lower() == &quot;bullish&quot;])
                bearish_count = len([s for s in ticker_signals.values() if s.get(&quot;signal&quot;, &quot;&quot;).lower() == &quot;bearish&quot;])
                neutral_count = len([s for s in ticker_signals.values() if s.get(&quot;signal&quot;, &quot;&quot;).lower() == &quot;neutral&quot;])

                # Calculate net position value
                pos = self.portfolio[&quot;positions&quot;][ticker]
                long_val = pos[&quot;long&quot;] * current_prices[ticker]
                short_val = pos[&quot;short&quot;] * current_prices[ticker]
                net_position_value = long_val - short_val

                # Get the action and quantity from the decisions
                action = decisions.get(ticker, {}).get(&quot;action&quot;, &quot;hold&quot;)
                quantity = executed_trades.get(ticker, 0)
                
                # Append the agent action to the table rows
                date_rows.append(
                    format_backtest_row(
                        date=current_date_str,
                        ticker=ticker,
                        action=action,
                        quantity=quantity,
                        price=current_prices[ticker],
                        shares_owned=pos[&quot;long&quot;] - pos[&quot;short&quot;],  # net shares
                        position_value=net_position_value,
                        bullish_count=bullish_count,
                        bearish_count=bearish_count,
                        neutral_count=neutral_count,
                    )
                )
            # ---------------------------------------------------------------
            # 4) Calculate performance summary metrics
            # ---------------------------------------------------------------
            total_realized_gains = sum(
                self.portfolio[&quot;realized_gains&quot;][t][&quot;long&quot;] +
                self.portfolio[&quot;realized_gains&quot;][t][&quot;short&quot;]
                for t in self.tickers
            )

            # Calculate cumulative return vs. initial capital
            portfolio_return = ((total_value + total_realized_gains) / self.initial_capital - 1) * 100

            # Add summary row for this day
            date_rows.append(
                format_backtest_row(
                    date=current_date_str,
                    ticker=&quot;&quot;,
                    action=&quot;&quot;,
                    quantity=0,
                    price=0,
                    shares_owned=0,
                    position_value=0,
                    bullish_count=0,
                    bearish_count=0,
                    neutral_count=0,
                    is_summary=True,
                    total_value=total_value,
                    return_pct=portfolio_return,
                    cash_balance=self.portfolio[&quot;cash&quot;],
                    total_position_value=total_value - self.portfolio[&quot;cash&quot;],
                    sharpe_ratio=performance_metrics[&quot;sharpe_ratio&quot;],
                    sortino_ratio=performance_metrics[&quot;sortino_ratio&quot;],
                    max_drawdown=performance_metrics[&quot;max_drawdown&quot;],
                ),
            )

            table_rows.extend(date_rows)
            print_backtest_results(table_rows)

            # Update performance metrics if we have enough data
            if len(self.portfolio_values) &gt; 3:
                self._update_performance_metrics(performance_metrics)

        return performance_metrics

    def _update_performance_metrics(self, performance_metrics):
        &quot;&quot;&quot;Helper method to update performance metrics using daily returns.&quot;&quot;&quot;
        values_df = pd.DataFrame(self.portfolio_values).set_index(&quot;Date&quot;)
        values_df[&quot;Daily Return&quot;] = values_df[&quot;Portfolio Value&quot;].pct_change()
        clean_returns = values_df[&quot;Daily Return&quot;].dropna()

        if len(clean_returns) &lt; 2:
            return  # not enough data points

        # Assumes 252 trading days/year
        daily_risk_free_rate = 0.0434 / 252
        excess_returns = clean_returns - daily_risk_free_rate
        mean_excess_return = excess_returns.mean()
        std_excess_return = excess_returns.std()

        # Sharpe ratio
        if std_excess_return &gt; 1e-12:
            performance_metrics[&quot;sharpe_ratio&quot;] = np.sqrt(252) * (mean_excess_return / std_excess_return)
        else:
            performance_metrics[&quot;sharpe_ratio&quot;] = 0.0

        # Sortino ratio
        negative_returns = excess_returns[excess_returns &lt; 0]
        if len(negative_returns) &gt; 0:
            downside_std = negative_returns.std()
            if downside_std &gt; 1e-12:
                performance_metrics[&quot;sortino_ratio&quot;] = np.sqrt(252) * (mean_excess_return / downside_std)
            else:
                performance_metrics[&quot;sortino_ratio&quot;] = float(&apos;inf&apos;) if mean_excess_return &gt; 0 else 0
        else:
            performance_metrics[&quot;sortino_ratio&quot;] = float(&apos;inf&apos;) if mean_excess_return &gt; 0 else 0

        # Maximum drawdown
        rolling_max = values_df[&quot;Portfolio Value&quot;].cummax()
        drawdown = (values_df[&quot;Portfolio Value&quot;] - rolling_max) / rolling_max
        performance_metrics[&quot;max_drawdown&quot;] = drawdown.min() * 100

    def analyze_performance(self):
        &quot;&quot;&quot;Creates a performance DataFrame, prints summary stats, and plots equity curve.&quot;&quot;&quot;
        if not self.portfolio_values:
            print(&quot;No portfolio data found. Please run the backtest first.&quot;)
            return pd.DataFrame()

        performance_df = pd.DataFrame(self.portfolio_values).set_index(&quot;Date&quot;)
        if performance_df.empty:
            print(&quot;No valid performance data to analyze.&quot;)
            return performance_df

        final_portfolio_value = performance_df[&quot;Portfolio Value&quot;].iloc[-1]
        total_realized_gains = sum(
            self.portfolio[&quot;realized_gains&quot;][ticker][&quot;long&quot;] for ticker in self.tickers
        )
        total_return = ((final_portfolio_value - self.initial_capital) / self.initial_capital) * 100

        print(f&quot;\n{Fore.WHITE}{Style.BRIGHT}PORTFOLIO PERFORMANCE SUMMARY:{Style.RESET_ALL}&quot;)
        print(f&quot;Total Return: {Fore.GREEN if total_return &gt;= 0 else Fore.RED}{total_return:.2f}%{Style.RESET_ALL}&quot;)
        print(f&quot;Total Realized Gains/Losses: {Fore.GREEN if total_realized_gains &gt;= 0 else Fore.RED}${total_realized_gains:,.2f}{Style.RESET_ALL}&quot;)

        # Plot the portfolio value over time
        plt.figure(figsize=(12, 6))
        plt.plot(performance_df.index, performance_df[&quot;Portfolio Value&quot;], color=&quot;blue&quot;)
        plt.title(&quot;Portfolio Value Over Time&quot;)
        plt.ylabel(&quot;Portfolio Value ($)&quot;)
        plt.xlabel(&quot;Date&quot;)
        plt.grid(True)
        plt.show()

        # Compute daily returns
        performance_df[&quot;Daily Return&quot;] = performance_df[&quot;Portfolio Value&quot;].pct_change().fillna(0)
        daily_rf = 0.0434 / 252  # daily risk-free rate
        mean_daily_return = performance_df[&quot;Daily Return&quot;].mean()
        std_daily_return = performance_df[&quot;Daily Return&quot;].std()

        # Annualized Sharpe Ratio
        if std_daily_return != 0:
            annualized_sharpe = np.sqrt(252) * ((mean_daily_return - daily_rf) / std_daily_return)
        else:
            annualized_sharpe = 0
        print(f&quot;\nSharpe Ratio: {Fore.YELLOW}{annualized_sharpe:.2f}{Style.RESET_ALL}&quot;)

        # Max Drawdown
        rolling_max = performance_df[&quot;Portfolio Value&quot;].cummax()
        drawdown = (performance_df[&quot;Portfolio Value&quot;] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        max_drawdown_date = drawdown.idxmin()
        if pd.notnull(max_drawdown_date):
            print(f&quot;Maximum Drawdown: {Fore.RED}{max_drawdown * 100:.2f}%{Style.RESET_ALL} (on {max_drawdown_date.strftime(&apos;%Y-%m-%d&apos;)})&quot;)
        else:
            print(f&quot;Maximum Drawdown: {Fore.RED}0.00%{Style.RESET_ALL}&quot;)

        # Win Rate
        winning_days = len(performance_df[performance_df[&quot;Daily Return&quot;] &gt; 0])
        total_days = max(len(performance_df) - 1, 1)
        win_rate = (winning_days / total_days) * 100
        print(f&quot;Win Rate: {Fore.GREEN}{win_rate:.2f}%{Style.RESET_ALL}&quot;)

        # Average Win/Loss Ratio
        positive_returns = performance_df[performance_df[&quot;Daily Return&quot;] &gt; 0][&quot;Daily Return&quot;]
        negative_returns = performance_df[performance_df[&quot;Daily Return&quot;] &lt; 0][&quot;Daily Return&quot;]
        avg_win = positive_returns.mean() if not positive_returns.empty else 0
        avg_loss = abs(negative_returns.mean()) if not negative_returns.empty else 0
        if avg_loss != 0:
            win_loss_ratio = avg_win / avg_loss
        else:
            win_loss_ratio = float(&apos;inf&apos;) if avg_win &gt; 0 else 0
        print(f&quot;Win/Loss Ratio: {Fore.GREEN}{win_loss_ratio:.2f}{Style.RESET_ALL}&quot;)

        # Maximum Consecutive Wins / Losses
        returns_binary = (performance_df[&quot;Daily Return&quot;] &gt; 0).astype(int)
        if len(returns_binary) &gt; 0:
            max_consecutive_wins = max((len(list(g)) for k, g in itertools.groupby(returns_binary) if k == 1), default=0)
            max_consecutive_losses = max((len(list(g)) for k, g in itertools.groupby(returns_binary) if k == 0), default=0)
        else:
            max_consecutive_wins = 0
            max_consecutive_losses = 0

        print(f&quot;Max Consecutive Wins: {Fore.GREEN}{max_consecutive_wins}{Style.RESET_ALL}&quot;)
        print(f&quot;Max Consecutive Losses: {Fore.RED}{max_consecutive_losses}{Style.RESET_ALL}&quot;)

        return performance_df


### 4. Run the Backtest #####
if __name__ == &quot;__main__&quot;:
    import argparse

    parser = argparse.ArgumentParser(description=&quot;Run backtesting simulation&quot;)
    parser.add_argument(
        &quot;--tickers&quot;,
        type=str,
        required=False,
        help=&quot;Comma-separated list of stock ticker symbols (e.g., AAPL,MSFT,GOOGL)&quot;,
    )
    parser.add_argument(
        &quot;--end-date&quot;,
        type=str,
        default=datetime.now().strftime(&quot;%Y-%m-%d&quot;),
        help=&quot;End date in YYYY-MM-DD format&quot;,
    )
    parser.add_argument(
        &quot;--start-date&quot;,
        type=str,
        default=(datetime.now() - relativedelta(months=1)).strftime(&quot;%Y-%m-%d&quot;),
        help=&quot;Start date in YYYY-MM-DD format&quot;,
    )
    parser.add_argument(
        &quot;--initial-capital&quot;,
        type=float,
        default=100000,
        help=&quot;Initial capital amount (default: 100000)&quot;,
    )
    parser.add_argument(
        &quot;--margin-requirement&quot;,
        type=float,
        default=0.0,
        help=&quot;Margin ratio for short positions, e.g. 0.5 for 50% (default: 0.0)&quot;,
    )

    args = parser.parse_args()

    # Parse tickers from comma-separated string
    tickers = [ticker.strip() for ticker in args.tickers.split(&quot;,&quot;)] if args.tickers else []

    # Choose analysts
    selected_analysts = None
    choices = questionary.checkbox(
        &quot;Use the Space bar to select/unselect analysts.&quot;,
        choices=[questionary.Choice(display, value=value) for display, value in ANALYST_ORDER],
        instruction=&quot;\n\nPress &apos;a&apos; to toggle all.\n\nPress Enter when done to run the hedge fund.&quot;,
        validate=lambda x: len(x) &gt; 0 or &quot;You must select at least one analyst.&quot;,
        style=questionary.Style(
            [
                (&quot;checkbox-selected&quot;, &quot;fg:green&quot;),
                (&quot;selected&quot;, &quot;fg:green noinherit&quot;),
                (&quot;highlighted&quot;, &quot;noinherit&quot;),
                (&quot;pointer&quot;, &quot;noinherit&quot;),
            ]
        ),
    ).ask()

    if not choices:
        print(&quot;\n\nInterrupt received. Exiting...&quot;)
        sys.exit(0)
    else:
        selected_analysts = choices
        print(
            f&quot;\nSelected analysts: &quot;
            f&quot;{&apos;, &apos;.join(Fore.GREEN + choice.title().replace(&apos;_&apos;, &apos; &apos;) + Style.RESET_ALL for choice in choices)}&quot;
        )

    # Select LLM model
    model_choice = questionary.select(
        &quot;Select your LLM model:&quot;,
        choices=[questionary.Choice(display, value=value) for display, value, _ in LLM_ORDER],
        style=questionary.Style([
            (&quot;selected&quot;, &quot;fg:green bold&quot;),
            (&quot;pointer&quot;, &quot;fg:green bold&quot;),
            (&quot;highlighted&quot;, &quot;fg:green&quot;),
            (&quot;answer&quot;, &quot;fg:green bold&quot;),
        ])
    ).ask()

    if not model_choice:
        print(&quot;\n\nInterrupt received. Exiting...&quot;)
        sys.exit(0)
    else:
        model_info = get_model_info(model_choice)
        if model_info:
            model_provider = model_info.provider.value
            print(f&quot;\nSelected {Fore.CYAN}{model_provider}{Style.RESET_ALL} model: {Fore.GREEN + Style.BRIGHT}{model_choice}{Style.RESET_ALL}\n&quot;)
        else:
            model_provider = &quot;Unknown&quot;
            print(f&quot;\nSelected model: {Fore.GREEN + Style.BRIGHT}{model_choice}{Style.RESET_ALL}\n&quot;)

    # Create and run the backtester
    backtester = Backtester(
        agent=run_hedge_fund,
        tickers=tickers,
        start_date=args.start_date,
        end_date=args.end_date,
        initial_capital=args.initial_capital,
        model_name=model_choice,
        model_provider=model_provider,
        selected_analysts=selected_analysts,
        initial_margin_requirement=args.margin_requirement,
    )

    performance_metrics = backtester.run_backtest()
    performance_df = backtester.analyze_performance()</file><file path="src/main.py">import sys

from dotenv import load_dotenv
from langchain_core.messages import HumanMessage
from langgraph.graph import END, StateGraph
from colorama import Fore, Back, Style, init
import questionary
from agents.ben_graham import ben_graham_agent
from agents.bill_ackman import bill_ackman_agent
from agents.fundamentals import fundamentals_agent
from agents.portfolio_manager import portfolio_management_agent
from agents.technicals import technical_analyst_agent
from agents.risk_manager import risk_management_agent
from agents.sentiment import sentiment_agent
from agents.warren_buffett import warren_buffett_agent
from graph.state import AgentState
from agents.valuation import valuation_agent
from utils.display import print_trading_output
from utils.analysts import ANALYST_ORDER, get_analyst_nodes
from utils.progress import progress
from llm.models import LLM_ORDER, get_model_info

import argparse
from datetime import datetime
from dateutil.relativedelta import relativedelta
from tabulate import tabulate
from utils.visualize import save_graph_as_png
import json

# Load environment variables from .env file
load_dotenv()

init(autoreset=True)


def parse_hedge_fund_response(response):
    &quot;&quot;&quot;Parses a JSON string and returns a dictionary.&quot;&quot;&quot;
    try:
        return json.loads(response)
    except json.JSONDecodeError as e:
        print(f&quot;JSON decoding error: {e}\nResponse: {repr(response)}&quot;)
        return None
    except TypeError as e:
        print(f&quot;Invalid response type (expected string, got {type(response).__name__}): {e}&quot;)
        return None
    except Exception as e:
        print(f&quot;Unexpected error while parsing response: {e}\nResponse: {repr(response)}&quot;)
        return None



##### Run the Hedge Fund #####
def run_hedge_fund(
    tickers: list[str],
    start_date: str,
    end_date: str,
    portfolio: dict,
    show_reasoning: bool = False,
    selected_analysts: list[str] = [],
    model_name: str = &quot;gpt-4o&quot;,
    model_provider: str = &quot;OpenAI&quot;,
):
    # Start progress tracking
    progress.start()

    try:
        # Create a new workflow if analysts are customized
        if selected_analysts:
            workflow = create_workflow(selected_analysts)
            agent = workflow.compile()
        else:
            agent = app

        final_state = agent.invoke(
            {
                &quot;messages&quot;: [
                    HumanMessage(
                        content=&quot;Make trading decisions based on the provided data.&quot;,
                    )
                ],
                &quot;data&quot;: {
                    &quot;tickers&quot;: tickers,
                    &quot;portfolio&quot;: portfolio,
                    &quot;start_date&quot;: start_date,
                    &quot;end_date&quot;: end_date,
                    &quot;analyst_signals&quot;: {},
                },
                &quot;metadata&quot;: {
                    &quot;show_reasoning&quot;: show_reasoning,
                    &quot;model_name&quot;: model_name,
                    &quot;model_provider&quot;: model_provider,
                },
            },
        )

        return {
            &quot;decisions&quot;: parse_hedge_fund_response(final_state[&quot;messages&quot;][-1].content),
            &quot;analyst_signals&quot;: final_state[&quot;data&quot;][&quot;analyst_signals&quot;],
        }
    finally:
        # Stop progress tracking
        progress.stop()


def start(state: AgentState):
    &quot;&quot;&quot;Initialize the workflow with the input message.&quot;&quot;&quot;
    return state


def create_workflow(selected_analysts=None):
    &quot;&quot;&quot;Create the workflow with selected analysts.&quot;&quot;&quot;
    workflow = StateGraph(AgentState)
    workflow.add_node(&quot;start_node&quot;, start)

    # Get analyst nodes from the configuration
    analyst_nodes = get_analyst_nodes()

    # Default to all analysts if none selected
    if selected_analysts is None:
        selected_analysts = list(analyst_nodes.keys())
    # Add selected analyst nodes
    for analyst_key in selected_analysts:
        node_name, node_func = analyst_nodes[analyst_key]
        workflow.add_node(node_name, node_func)
        workflow.add_edge(&quot;start_node&quot;, node_name)

    # Always add risk and portfolio management
    workflow.add_node(&quot;risk_management_agent&quot;, risk_management_agent)
    workflow.add_node(&quot;portfolio_management_agent&quot;, portfolio_management_agent)

    # Connect selected analysts to risk management
    for analyst_key in selected_analysts:
        node_name = analyst_nodes[analyst_key][0]
        workflow.add_edge(node_name, &quot;risk_management_agent&quot;)

    workflow.add_edge(&quot;risk_management_agent&quot;, &quot;portfolio_management_agent&quot;)
    workflow.add_edge(&quot;portfolio_management_agent&quot;, END)

    workflow.set_entry_point(&quot;start_node&quot;)
    return workflow


if __name__ == &quot;__main__&quot;:
    parser = argparse.ArgumentParser(description=&quot;Run the hedge fund trading system&quot;)
    parser.add_argument(
        &quot;--initial-cash&quot;,
        type=float,
        default=100000.0,
        help=&quot;Initial cash position. Defaults to 100000.0)&quot;
    )
    parser.add_argument(
        &quot;--margin-requirement&quot;,
        type=float,
        default=0.0,
        help=&quot;Initial margin requirement. Defaults to 0.0&quot;
    )
    parser.add_argument(&quot;--tickers&quot;, type=str, required=True, help=&quot;Comma-separated list of stock ticker symbols&quot;)
    parser.add_argument(
        &quot;--start-date&quot;,
        type=str,
        help=&quot;Start date (YYYY-MM-DD). Defaults to 3 months before end date&quot;,
    )
    parser.add_argument(&quot;--end-date&quot;, type=str, help=&quot;End date (YYYY-MM-DD). Defaults to today&quot;)
    parser.add_argument(&quot;--show-reasoning&quot;, action=&quot;store_true&quot;, help=&quot;Show reasoning from each agent&quot;)
    parser.add_argument(
        &quot;--show-agent-graph&quot;, action=&quot;store_true&quot;, help=&quot;Show the agent graph&quot;
    )

    args = parser.parse_args()

    # Parse tickers from comma-separated string
    tickers = [ticker.strip() for ticker in args.tickers.split(&quot;,&quot;)]

    # Select analysts
    selected_analysts = None
    choices = questionary.checkbox(
        &quot;Select your AI analysts.&quot;,
        choices=[questionary.Choice(display, value=value) for display, value in ANALYST_ORDER],
        instruction=&quot;\n\nInstructions: \n1. Press Space to select/unselect analysts.\n2. Press &apos;a&apos; to select/unselect all.\n3. Press Enter when done to run the hedge fund.\n&quot;,
        validate=lambda x: len(x) &gt; 0 or &quot;You must select at least one analyst.&quot;,
        style=questionary.Style(
            [
                (&quot;checkbox-selected&quot;, &quot;fg:green&quot;),
                (&quot;selected&quot;, &quot;fg:green noinherit&quot;),
                (&quot;highlighted&quot;, &quot;noinherit&quot;),
                (&quot;pointer&quot;, &quot;noinherit&quot;),
            ]
        ),
    ).ask()

    if not choices:
        print(&quot;\n\nInterrupt received. Exiting...&quot;)
        sys.exit(0)
    else:
        selected_analysts = choices
        print(f&quot;\nSelected analysts: {&apos;, &apos;.join(Fore.GREEN + choice.title().replace(&apos;_&apos;, &apos; &apos;) + Style.RESET_ALL for choice in choices)}\n&quot;)

    # Select LLM model
    model_choice = questionary.select(
        &quot;Select your LLM model:&quot;,
        choices=[questionary.Choice(display, value=value) for display, value, _ in LLM_ORDER],
        style=questionary.Style([
            (&quot;selected&quot;, &quot;fg:green bold&quot;),
            (&quot;pointer&quot;, &quot;fg:green bold&quot;),
            (&quot;highlighted&quot;, &quot;fg:green&quot;),
            (&quot;answer&quot;, &quot;fg:green bold&quot;),
        ])
    ).ask()

    if not model_choice:
        print(&quot;\n\nInterrupt received. Exiting...&quot;)
        sys.exit(0)
    else:
        # Get model info using the helper function
        model_info = get_model_info(model_choice)
        if model_info:
            model_provider = model_info.provider.value
            print(f&quot;\nSelected {Fore.CYAN}{model_provider}{Style.RESET_ALL} model: {Fore.GREEN + Style.BRIGHT}{model_choice}{Style.RESET_ALL}\n&quot;)
        else:
            model_provider = &quot;Unknown&quot;
            print(f&quot;\nSelected model: {Fore.GREEN + Style.BRIGHT}{model_choice}{Style.RESET_ALL}\n&quot;)

    # Create the workflow with selected analysts
    workflow = create_workflow(selected_analysts)
    app = workflow.compile()

    if args.show_agent_graph:
        file_path = &quot;&quot;
        if selected_analysts is not None:
            for selected_analyst in selected_analysts:
                file_path += selected_analyst + &quot;_&quot;
            file_path += &quot;graph.png&quot;
        save_graph_as_png(app, file_path)

    # Validate dates if provided
    if args.start_date:
        try:
            datetime.strptime(args.start_date, &quot;%Y-%m-%d&quot;)
        except ValueError:
            raise ValueError(&quot;Start date must be in YYYY-MM-DD format&quot;)

    if args.end_date:
        try:
            datetime.strptime(args.end_date, &quot;%Y-%m-%d&quot;)
        except ValueError:
            raise ValueError(&quot;End date must be in YYYY-MM-DD format&quot;)

    # Set the start and end dates
    end_date = args.end_date or datetime.now().strftime(&quot;%Y-%m-%d&quot;)
    if not args.start_date:
        # Calculate 3 months before end_date
        end_date_obj = datetime.strptime(end_date, &quot;%Y-%m-%d&quot;)
        start_date = (end_date_obj - relativedelta(months=3)).strftime(&quot;%Y-%m-%d&quot;)
    else:
        start_date = args.start_date

    # Initialize portfolio with cash amount and stock positions
    portfolio = {
        &quot;cash&quot;: args.initial_cash,  # Initial cash amount
        &quot;margin_requirement&quot;: args.margin_requirement,  # Initial margin requirement
        &quot;positions&quot;: {
            ticker: {
                &quot;long&quot;: 0,  # Number of shares held long
                &quot;short&quot;: 0,  # Number of shares held short
                &quot;long_cost_basis&quot;: 0.0,  # Average cost basis for long positions
                &quot;short_cost_basis&quot;: 0.0,  # Average price at which shares were sold short
            } for ticker in tickers
        },
        &quot;realized_gains&quot;: {
            ticker: {
                &quot;long&quot;: 0.0,  # Realized gains from long positions
                &quot;short&quot;: 0.0,  # Realized gains from short positions
            } for ticker in tickers
        }
    }

    # Run the hedge fund
    result = run_hedge_fund(
        tickers=tickers,
        start_date=start_date,
        end_date=end_date,
        portfolio=portfolio,
        show_reasoning=args.show_reasoning,
        selected_analysts=selected_analysts,
        model_name=model_choice,
        model_provider=model_provider,
    )
    print_trading_output(result)</file><file path=".env.example"># For running LLMs hosted by anthropic (claude-3-5-sonnet, claude-3-opus, claude-3-5-haiku)
# Get your Anthropic API key from https://anthropic.com/
ANTHROPIC_API_KEY=your-anthropic-api-key
# For running LLMs hosted by deepseek (deepseek-chat, deepseek-reasoner, etc.)
# Get your DeepSeek API key from https://deepseek.com/
DEEPSEEK_API_KEY=your-deepseek-api-key

# For running LLMs hosted by groq (deepseek, llama3, etc.)
# Get your Groq API key from https://groq.com/
GROQ_API_KEY=your-groq-api-key

# For running LLMs hosted by gemini (gemini-2.0-flash, gemini-2.0-pro)
# Get your Google API key from https://console.cloud.google.com/
GOOGLE_API_KEY=your-google-api-key
# For getting financial data to power the hedge fund
# Get your Financial Datasets API key from https://financialdatasets.ai/
FINANCIAL_DATASETS_API_KEY=your-financial-datasets-api-key
# For running LLMs hosted by openai (gpt-4o, gpt-4o-mini, etc.)
# Get your OpenAI API key from https://platform.openai.com/
OPENAI_API_KEY=your-openai-api-key</file><file path=".gitignore"># Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/

# Environment Variables
.env

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# graph
*.png

# Txt files
*.txt</file><file path="LICENSE">MIT License

Copyright (c) 2024 Virat Singh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</file><file path="pyproject.toml">[tool.poetry]
name = &quot;ai-hedge-fund&quot;
version = &quot;0.1.0&quot;
description = &quot;An AI-powered hedge fund that uses multiple agents to make trading decisions&quot;
authors = [&quot;Your Name &lt;your.email@example.com&gt;&quot;]
readme = &quot;README.md&quot;
packages = [
    { include = &quot;src&quot;, from = &quot;.&quot; }
]
[tool.poetry.dependencies]
python = &quot;^3.9&quot;
langchain = &quot;0.3.0&quot;
langchain-anthropic = &quot;0.3.5&quot;
langchain-groq = &quot;0.2.3&quot;
langchain-openai = &quot;^0.3.5&quot;
langchain-deepseek = &quot;^0.1.2&quot;
langgraph = &quot;0.2.56&quot;
pandas = &quot;^2.1.0&quot;
numpy = &quot;^1.24.0&quot;
python-dotenv = &quot;1.0.0&quot;
matplotlib = &quot;^3.9.2&quot;
tabulate = &quot;^0.9.0&quot;
colorama = &quot;^0.4.6&quot;
questionary = &quot;^2.1.0&quot;
rich = &quot;^13.9.4&quot;
langchain-google-genai = &quot;^2.0.11&quot;

[tool.poetry.group.dev.dependencies]
pytest = &quot;^7.4.0&quot;
black = &quot;^23.7.0&quot;
isort = &quot;^5.12.0&quot;
flake8 = &quot;^6.1.0&quot;

[build-system]
requires = [&quot;poetry-core&quot;]
build-backend = &quot;poetry.core.masonry.api&quot;

[tool.black]
line-length = 420
target-version = [&apos;py39&apos;]
include = &apos;\.pyi?$&apos;</file><file path="README.md"># AI Hedge Fund

This is a proof of concept for an AI-powered hedge fund.  The goal of this project is to explore the use of AI to make trading decisions.  This project is for **educational** purposes only and is not intended for real trading or investment.

This system employs several agents working together:

1. Ben Graham Agent - The godfather of value investing, only buys hidden gems with a margin of safety
2. Bill Ackman Agent - An activist investors, takes bold positions and pushes for change
3. Cathie Wood Agent - The queen of growth investing, believes in the power of innovation and disruption
4. Charlie Munger Agent - Warren Buffett&apos;s partner, only buys wonderful businesses at fair prices
5. Stanley Druckenmiller Agent - Macro trading legend who hunts for asymmetric opportunities with explosive growth potential
6. Warren Buffett Agent - The oracle of Omaha, seeks wonderful companies at a fair price
7. Valuation Agent - Calculates the intrinsic value of a stock and generates trading signals
8. Sentiment Agent - Analyzes market sentiment and generates trading signals
9. Fundamentals Agent - Analyzes fundamental data and generates trading signals
10. Technicals Agent - Analyzes technical indicators and generates trading signals
11. Risk Manager - Calculates risk metrics and sets position limits
12. Portfolio Manager - Makes final trading decisions and generates orders

&lt;img width=&quot;1020&quot; alt=&quot;Screenshot 2025-03-08 at 4 45 22â€¯PM&quot; src=&quot;https://github.com/user-attachments/assets/d8ab891e-a083-4fed-b514-ccc9322a3e57&quot; /&gt;

**Note**: the system simulates trading decisions, it does not actually trade.

[![Twitter Follow](https://img.shields.io/twitter/follow/virattt?style=social)](https://twitter.com/virattt)

## Disclaimer

This project is for **educational and research purposes only**.

- Not intended for real trading or investment
- No warranties or guarantees provided
- Past performance does not indicate future results
- Creator assumes no liability for financial losses
- Consult a financial advisor for investment decisions

By using this software, you agree to use it solely for learning purposes.

## Table of Contents
- [Setup](#setup)
- [Usage](#usage)
  - [Running the Hedge Fund](#running-the-hedge-fund)
  - [Running the Backtester](#running-the-backtester)
- [Project Structure](#project-structure)
- [Contributing](#contributing)
- [Feature Requests](#feature-requests)
- [License](#license)

## Setup

Clone the repository:
```bash
git clone https://github.com/virattt/ai-hedge-fund.git
cd ai-hedge-fund
```

1. Install Poetry (if not already installed):
```bash
curl -sSL https://install.python-poetry.org | python3 -
```

2. Install dependencies:
```bash
poetry install
```

3. Set up your environment variables:
```bash
# Create .env file for your API keys
cp .env.example .env
```

4. Set your API keys:
```bash
# For running LLMs hosted by openai (gpt-4o, gpt-4o-mini, etc.)
# Get your OpenAI API key from https://platform.openai.com/
OPENAI_API_KEY=your-openai-api-key

# For running LLMs hosted by groq (deepseek, llama3, etc.)
# Get your Groq API key from https://groq.com/
GROQ_API_KEY=your-groq-api-key

# For getting financial data to power the hedge fund
# Get your Financial Datasets API key from https://financialdatasets.ai/
FINANCIAL_DATASETS_API_KEY=your-financial-datasets-api-key
```

**Important**: You must set `OPENAI_API_KEY`, `GROQ_API_KEY`, `ANTHROPIC_API_KEY`, or `DEEPSEEK_API_KEY` for the hedge fund to work.  If you want to use LLMs from all providers, you will need to set all API keys.

Financial data for AAPL, GOOGL, MSFT, NVDA, and TSLA is free and does not require an API key.

For any other ticker, you will need to set the `FINANCIAL_DATASETS_API_KEY` in the .env file.

## Usage

### Running the Hedge Fund
```bash
poetry run python src/main.py --ticker AAPL,MSFT,NVDA
```

**Example Output:**
&lt;img width=&quot;992&quot; alt=&quot;Screenshot 2025-01-06 at 5 50 17â€¯PM&quot; src=&quot;https://github.com/user-attachments/assets/e8ca04bf-9989-4a7d-a8b4-34e04666663b&quot; /&gt;

You can also specify a `--show-reasoning` flag to print the reasoning of each agent to the console.

```bash
poetry run python src/main.py --ticker AAPL,MSFT,NVDA --show-reasoning
```
You can optionally specify the start and end dates to make decisions for a specific time period.

```bash
poetry run python src/main.py --ticker AAPL,MSFT,NVDA --start-date 2024-01-01 --end-date 2024-03-01 
```

### Running the Backtester

```bash
poetry run python src/backtester.py --ticker AAPL,MSFT,NVDA
```

**Example Output:**
&lt;img width=&quot;941&quot; alt=&quot;Screenshot 2025-01-06 at 5 47 52â€¯PM&quot; src=&quot;https://github.com/user-attachments/assets/00e794ea-8628-44e6-9a84-8f8a31ad3b47&quot; /&gt;

You can optionally specify the start and end dates to backtest over a specific time period.

```bash
poetry run python src/backtester.py --ticker AAPL,MSFT,NVDA --start-date 2024-01-01 --end-date 2024-03-01
```

## Project Structure 
```
ai-hedge-fund/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ agents/                   # Agent definitions and workflow
â”‚   â”‚   â”œâ”€â”€ bill_ackman.py        # Bill Ackman agent
â”‚   â”‚   â”œâ”€â”€ fundamentals.py       # Fundamental analysis agent
â”‚   â”‚   â”œâ”€â”€ portfolio_manager.py  # Portfolio management agent
â”‚   â”‚   â”œâ”€â”€ risk_manager.py       # Risk management agent
â”‚   â”‚   â”œâ”€â”€ sentiment.py          # Sentiment analysis agent
â”‚   â”‚   â”œâ”€â”€ technicals.py         # Technical analysis agent
â”‚   â”‚   â”œâ”€â”€ valuation.py          # Valuation analysis agent
â”‚   â”‚   â”œâ”€â”€ warren_buffett.py     # Warren Buffett agent
â”‚   â”œâ”€â”€ tools/                    # Agent tools
â”‚   â”‚   â”œâ”€â”€ api.py                # API tools
â”‚   â”œâ”€â”€ backtester.py             # Backtesting tools
â”‚   â”œâ”€â”€ main.py # Main entry point
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ ...
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

**Important**: Please keep your pull requests small and focused.  This will make it easier to review and merge.

## Feature Requests

If you have a feature request, please open an [issue](https://github.com/virattt/ai-hedge-fund/issues) and make sure it is tagged with `enhancement`.

## License

This project is licensed under the MIT License - see the LICENSE file for details.</file></files></repomix>